"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[2512],{2671:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=t(85893),a=t(11151);const i={sidebar_position:3},s="Mint",o={id:"tutorials/from-zero-to-ink-hero/dex/Pair/mint",title:"Mint",description:"If you are starting the tutorial from here, please check out this branch and open it in your IDE.",source:"@site/docs/tutorials/from-zero-to-ink-hero/dex/Pair/mint.md",sourceDirName:"tutorials/from-zero-to-ink-hero/dex/Pair",slug:"/tutorials/from-zero-to-ink-hero/dex/Pair/mint",permalink:"/docs/tutorials/from-zero-to-ink-hero/dex/Pair/mint",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/tutorials/from-zero-to-ink-hero/dex/Pair/mint.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Pair Storage and Getters",permalink:"/docs/tutorials/from-zero-to-ink-hero/dex/Pair/storage"},next:{title:"Burn",permalink:"/docs/tutorials/from-zero-to-ink-hero/dex/Pair/burn"}},l={},c=[{value:"1. Add Mint Functions to Pair Trait",id:"1-add-mint-functions-to-pair-trait",level:3},{value:"2. Mint Fee and Factory Trait",id:"2-mint-fee-and-factory-trait",level:3},{value:"3. Update",id:"3-update",level:3},{value:"4. Mint",id:"4-mint",level:3},{value:"5. Implement Event",id:"5-implement-event",level:3}];function d(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"mint",children:"Mint"}),"\n",(0,r.jsxs)(n.p,{children:["If you are starting the tutorial from here, please check out this ",(0,r.jsx)(n.a,{href:"https://github.com/AstarNetwork/wasm-tutorial-dex/tree/tutorial/storage-end",children:"branch"})," and open it in your IDE."]}),"\n",(0,r.jsx)(n.h3,{id:"1-add-mint-functions-to-pair-trait",children:"1. Add Mint Functions to Pair Trait"}),"\n",(0,r.jsxs)(n.p,{children:["At this stage, we will implement the ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L110",children:"mint"})," function of the Pair contract.",(0,r.jsx)(n.br,{}),"\n","In the ",(0,r.jsx)(n.em,{children:"./logics/traits/pair.rs"})," file add the ",(0,r.jsx)(n.strong,{children:"mint"})," function to the Pair trait. You should also add two internal ",(0,r.jsx)(n.strong,{children:"_mint_fee"})," and ",(0,r.jsx)(n.strong,{children:"_update"})," functions.\nAs those functions modify the state, they should take a ",(0,r.jsx)(n.code,{children:"&mut self"})," as first argument. When sending transaction (as tx) it return nothing (a tx cannot return a value neither a variant of the Error enum) so in most cases state changes function will return ",(0,r.jsx)(n.code,{children:"Result<(), PairError>"}),".\nBut if you call the function as dry-run (as a query, it will not modify the state) it can return a value (any value and Error enum as well). That is why the ",(0,r.jsx)(n.strong,{children:"mint"})," message function returns a ",(0,r.jsx)(n.code,{children:"Balance"})," (and not ",(0,r.jsx)(n.code,{children:"()"}),"). So before calling ",(0,r.jsx)(n.strong,{children:"mint"})," as tx you can call it as dry-run and gets the liquidity that will be minted.\nAlso add the function to emit mint event that will have to be implemented in the contract:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub trait Pair {\n    ...\n    #[ink(message)]\n    fn mint(&mut self, to: AccountId) -> Result<Balance, PairError>;\n\n    fn _mint_fee(&mut self, reserve_0: Balance, reserve_1: Balance) -> Result<bool, PairError>;\n    \n    fn _update(\n        &mut self,\n        balance_0: Balance,\n        balance_1: Balance,\n        reserve_0: Balance,\n        reserve_1: Balance,\n    ) -> Result<(), PairError>;\n    \n    fn _emit_mint_event(&self, _sender: AccountId, _amount_0: Balance, _amount_1: Balance);\n\n    fn _emit_sync_event(&self, reserve_0: Balance, reserve_1: Balance);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-mint-fee-and-factory-trait",children:"2. Mint Fee and Factory Trait"}),"\n",(0,r.jsxs)(n.p,{children:["As ",(0,r.jsx)(n.strong,{children:"_update"})," and ",(0,r.jsx)(n.strong,{children:"_mint_fee"})," are child functions of ",(0,r.jsx)(n.strong,{children:"mint"}),", let's start by implementing those.\nHave a look at ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L89",children:"_mintFee"})," in Solidity, which takes ",(0,r.jsx)(n.code,{children:"uint112 _reserve0"})," and ",(0,r.jsx)(n.code,{children:"uint112 _reserve1"}),"  as arguments, and translates to ",(0,r.jsx)(n.code,{children:"Balance"})," in ink! that returns a bool, and can make state changes (it can save ",(0,r.jsx)(n.code,{children:"k_last"})," to storage) so in ink! it should return ",(0,r.jsx)(n.code,{children:"Result<bool, PairError>"}),".",(0,r.jsx)(n.br,{}),"\n","Let's add it to ",(0,r.jsx)(n.em,{children:"./logics/impls/pair/pair.rs"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl<T: Storage<data::Data> + Storage<psp22::Data>> Pair for T {\n    ...\n    fn _mint_fee(\n        &mut self,\n        reserve_0: Balance,\n        reserve_1: Balance,\n    ) -> Result<bool, PairError> {}\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L90",children:"first line"})," of ",(0,r.jsx)(n.strong,{children:"_mintFee"})," there is a cross-contract call to the Factory contract to obtain the address of the account collecting the fees. To do so we will use Openbrush wrapper around a Factory trait (and demonstrate that the trait only is needed - no implementation).\ncreate a file ",(0,r.jsx)(n.em,{children:"./logics/traits/factory.rs"})," and add the ",(0,r.jsx)(n.code,{children:"Factory"})," trait and a ",(0,r.jsx)(n.strong,{children:"fee_to"})," function getter.",(0,r.jsx)(n.br,{}),"\n","Add ",(0,r.jsx)(n.code,{children:"#[openbrush::trait_definition]"})," to the top of the file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"#[openbrush::trait_definition]\npub trait Factory {\n    #[ink(message)]\n    fn fee_to(&self) -> AccountId;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"And then add a wrapper around this trait. Imports what needs to be imported:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use openbrush::traits::AccountId;\n\n#[openbrush::wrapper]\npub type FactoryRef = dyn Factory;\n...\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Add this file to ",(0,r.jsx)(n.em,{children:"./logics/traits/mod.rs"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub mod pair;\npub mod factory;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.em,{children:"./logics/impls/pair/pair.rs"})," import this contract ",(0,r.jsx)(n.code,{children:"FactoryRef"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use crate::traits::factory::FactoryRef;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And in the body of ",(0,r.jsx)(n.strong,{children:"_mint_fee"})," we will obtain the ",(0,r.jsx)(n.code,{children:"fee_to"})," with a cross-contract call to Factory. When using OpenBrush wrapper around a trait, the first argument of the function should be the contract address you call. So add this line as it is shown below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"    fn _mint_fee(\n        &mut self,\n        reserve_0: Balance,\n        reserve_1: Balance,\n    ) -> Result<bool, PairError> {\n    let fee_to = FactoryRef::fee_to(&self.data::<data::Data>().factory);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"The rest of the function body may be somewhat difficult to interpret, so here are a few tips:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.code,{children:" address(0)"})," in Solidity you can use ",(0,r.jsx)(n.code,{children:"openbrush::traits::ZERO_ADDRESS"})," (which is a const ",(0,r.jsx)(n.code,{children:"[0; 32]"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:["For ",(0,r.jsx)(n.code,{children:"sqrt"})," you can either implement the ",(0,r.jsx)(n.a,{href:"https://github.com/AstarNetwork/wasm-tutorial-dex/blob/4afd2d2a0503ad5dfcecd87e2b40d55cd3c854a0/uniswap-v2/logics/impls/pair/pair.rs#L437",children:"same function"})," or use ",(0,r.jsx)(n.a,{href:"https://crates.io/crates/integer-sqrt",children:"integer-sqrt"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["When doing Math operations you should handle overflow cases (and return an Error if there is an overflow). You can perform check operations on ",(0,r.jsx)(n.code,{children:"u128"})]}),"\n",(0,r.jsx)(n.li,{children:"Use each Error variant only once, so when testing or debugging you will know immediately which line the Error come from."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Then implement line-by-line the same logic as in Uniswap-V2:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"    fn _mint_fee(\n    &mut self,\n    reserve_0: Balance,\n    reserve_1: Balance,\n) -> Result<bool, PairError> {\n    let fee_to = FactoryRef::fee_to(&self.data::<data::Data>().factory);\n    let fee_on = fee_to != ZERO_ADDRESS.into();\n    let k_last = self.data::<data::Data>().k_last;\n    if fee_on {\n        if k_last != 0 {\n            let root_k = sqrt(\n                reserve_0\n                    .checked_mul(reserve_1)\n                    .ok_or(PairError::MulOverFlow14)?,\n            );\n            let root_k_last = sqrt(k_last);\n            if root_k > root_k_last {\n                let total_supply = self.data::<psp22::Data>().supply;\n                let numerator = total_supply\n                    .checked_mul(\n                        root_k\n                            .checked_sub(root_k_last)\n                            .ok_or(PairError::SubUnderFlow14)?,\n                    )\n                    .ok_or(PairError::MulOverFlow15)?;\n                let denominator = root_k\n                    .checked_mul(5)\n                    .ok_or(PairError::MulOverFlow15)?\n                    .checked_add(root_k_last)\n                    .ok_or(PairError::AddOverflow1)?;\n                let liquidity = numerator\n                    .checked_div(denominator)\n                    .ok_or(PairError::DivByZero5)?;\n                if liquidity > 0 {\n                    self._mint_to(fee_to, liquidity)?;\n                }\n            }\n        }\n    } else if k_last != 0 {\n        self.data::<data::Data>().k_last = 0;\n    }\n    Ok(fee_on)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-update",children:"3. Update"}),"\n",(0,r.jsxs)(n.p,{children:["The update function will update the ",(0,r.jsx)(n.a,{href:"https://docs.uniswap.org/contracts/v2/concepts/core-concepts/oracles",children:"oracle price"})," of the tokens with time-weighted average prices (TWAPs). Please check the Uniswap V2 ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L73",children:"implementation"}),".",(0,r.jsx)(n.br,{}),"\n","To implement this in ink!:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["ink! contracts should ",(0,r.jsx)(n.a,{href:"https://substrate.stackexchange.com/questions/2391/panic-in-ink-smart-contracts",children:"never panic!"}),". The reason being that a panic! will give the user no information about the Error (it only returns ",(0,r.jsx)(n.code,{children:"CalleeTrapped"}),"). Every potential business/logical error should be returned in a predictable way using ",(0,r.jsx)(n.code,{children:"Result<T, Error>"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["To handle time use ",(0,r.jsx)(n.code,{children:"Self::env().block_timestamp()"})," that is the time in milliseconds since the Unix epoch."]}),"\n",(0,r.jsxs)(n.li,{children:["In Solidity, float point division is not supported, it uses Q number UQ112x112 for more precision. We will use div for our example (note that is the DEX template we use ",(0,r.jsx)(n.a,{href:"https://github.com/swanky-dapps/dex/blob/4676a73f4ab986a3a3f3de42be1b0052562953f1/uniswap-v2/logics/impls/pair/pair.rs#L374",children:"U256"})," for more precision)."]}),"\n",(0,r.jsxs)(n.li,{children:["To store values in storage (but first verify, then save), modify the value of the Storage field (as the function takes ",(0,r.jsx)(n.code,{children:"&mut self"})," it can modify Storage struct fields)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["You can then implement ",(0,r.jsx)(n.strong,{children:"update"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"    fn _update(\n    &mut self,\n    balance_0: Balance,\n    balance_1: Balance,\n    reserve_0: Balance,\n    reserve_1: Balance,\n) -> Result<(), PairError> {\n    if balance_0 == u128::MAX || balance_1 == u128::MAX {\n        return Err(PairError::Overflow)\n    }\n    let now = Self::env().block_timestamp();\n    let time_elapsed = now - self.data::<data::Data>().block_timestamp_last;\n    if time_elapsed > 0 && reserve_0 != 0 && reserve_1 != 0 {\n        let price_cumulative_last_0 = (reserve_1 / reserve_0)\n            .checked_mul(time_elapsed as u128)\n            .ok_or(PairError::MulOverFlow4)?;\n        let price_cumulative_last_1 = (reserve_0 / reserve_1)\n            .checked_mul(time_elapsed as u128)\n            .ok_or(PairError::MulOverFlow4)?;\n        self.data::<data::Data>().price_0_cumulative_last += price_cumulative_last_0;\n        self.data::<data::Data>().price_1_cumulative_last += price_cumulative_last_1;\n    }\n    self.data::<data::Data>().reserve_0 = balance_0;\n    self.data::<data::Data>().reserve_1 = balance_1;\n    self.data::<data::Data>().block_timestamp_last = now;\n\n    self._emit_sync_event(reserve_0, reserve_1);\n    Ok(())\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-mint",children:"4. Mint"}),"\n",(0,r.jsxs)(n.p,{children:["Now that all child functions have been added, we can add ",(0,r.jsx)(n.strong,{children:"mint"}),".\nFirst, add the function definition in the impl block of ",(0,r.jsx)(n.em,{children:"./logics/impls/pair/pair.rs"})," :"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn mint(&mut self, to: AccountId) -> Result<Balance, PairError> {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["On line ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Pair.sol#L112",children:"112"})," of ",(0,r.jsx)(n.em,{children:"Pair.sol"})," there is a cross-contract call to the ERC20 to obtain the balance of the contract ",(0,r.jsx)(n.code,{children:"uint balance0 = IERC20(token0).balanceOf(address(this));"}),".",(0,r.jsx)(n.br,{}),"\n","To implement this cross-contract call we will use ",(0,r.jsx)(n.code,{children:"PSP22Ref"})," from Openbrush. To obtain the address of the contract, use ",(0,r.jsx)(n.code,{children:"Self::env().account_id()"}),".\nRead more about how to find all the ink_env getters in this ",(0,r.jsx)(n.a,{href:"https://docs.rs/ink_env/latest/ink_env/",children:"doc"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["First, add the ",(0,r.jsx)(n.code,{children:"psp22::Data"})," Trait bound to the generic impl block:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl<T: Storage<data::Data> + Storage<psp22::Data>> Pair for T { \n    ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the body of ",(0,r.jsx)(n.strong,{children:"mint"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use openbrush::contracts::traits::psp22::PSP22Ref;\n...\nfn mint(&mut self, to: AccountId) -> Result<Balance, PairError> {\n    let reserves = self.get_reserves();\n    let contract = Self::env().account_id();\n    let balance_0 = PSP22Ref::balance_of(&self.data::<data::Data>().token_0, contract);\n    let balance_1 = PSP22Ref::balance_of(&self.data::<data::Data>().token_1, contract);\n    ...\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now, as the call to ",(0,r.jsx)(n.code,{children:"PSP22Ref"})," returns ",(0,r.jsx)(n.code,{children:"Result<Balance, PSP22Error>"})," we should implement the ",(0,r.jsx)(n.code,{children:"From"})," trait for our ",(0,r.jsx)(n.code,{children:"PairError"})," (to not have to map_err for every calls).\nWe will do so in the file ",(0,r.jsx)(n.em,{children:".logics/traits/pair.rs"})," where we defined ",(0,r.jsx)(n.code,{children:"PairError"}),". Add a field that takes an ",(0,r.jsx)(n.code,{children:"PSP22Error"}),", and implement the ",(0,r.jsx)(n.code,{children:"From"})," Trait for it (also add all the error fields used in the implementation):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use openbrush::contracts::psp22::PSP22Error;\n...\n#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]\npub enum PairError {\n    PSP22Error(PSP22Error),\n    InsufficientLiquidityMinted,\n    Overflow,\n    SubUnderFlow1,\n    SubUnderFlow2,\n    SubUnderFlow3,\n    SubUnderFlow14,\n    MulOverFlow1,\n    MulOverFlow2,\n    MulOverFlow3,\n    MulOverFlow4,\n    MulOverFlow5,\n    MulOverFlow14,\n    MulOverFlow15,\n    DivByZero1,\n    DivByZero2,\n    DivByZero5,\n    AddOverflow1,\n}\n\nimpl From<PSP22Error> for PairError {\n    fn from(error: PSP22Error) -> Self {\n        PairError::PSP22Error(error)\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.strong,{children:"MINIMUM_LIQUIDTY"})," constant, please add:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub const MINIMUM_LIQUIDITY: u128 = 1000;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For the ",(0,r.jsx)(n.strong,{children:"min"})," function, add the ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/libraries/Math.sol#L6",children:"same implementation"})," below the ",(0,r.jsx)(n.code,{children:"impl"})," block:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"    default fn _emit_mint_event(&self, _sender: AccountId, _amount_0: Balance, _amount_1: Balance) {}\n    \n    default fn _emit_sync_event(&self, _reserve_0: Balance, _reserve_1: Balance) {}\n}\n\nfn min(x: u128, y: u128) -> u128 {\n    if x < y {\n        return x\n    }\n    y\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.strong,{children:"sqrt"})," function add the ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/libraries/Math.sol#L11",children:"same implementation"})," below the ",(0,r.jsx)(n.strong,{children:"min"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn sqrt(y: u128) -> u128 {\n    let mut z = 1;\n    if y > 3 {\n        z = y;\n        let mut x = y / 2 + 1;\n        while x < z {\n            z = x;\n            x = (y / x + x) / 2;\n        }\n    }\n    z\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"If you handle all overflows (that requires most of the lines of the function body):"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"First obtain the values for reserves, balances and liquidity."}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"mint_fee"})}),"\n",(0,r.jsxs)(n.li,{children:["Mint liquidity to ",(0,r.jsx)(n.code,{children:"to"})]}),"\n",(0,r.jsx)(n.li,{children:"Update reserves."}),"\n",(0,r.jsx)(n.li,{children:"Emit an event."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"    fn mint(&mut self, to: AccountId) -> Result<Balance, PairError> {\n        let reserves = self.get_reserves();\n        let contract = Self::env().account_id();\n        let balance_0 = PSP22Ref::balance_of(&self.data::<data::Data>().token_0, contract);\n        let balance_1 = PSP22Ref::balance_of(&self.data::<data::Data>().token_1, contract);\n        let amount_0 = balance_0\n            .checked_sub(reserves.0)\n            .ok_or(PairError::SubUnderFlow1)?;\n        let amount_1 = balance_1\n            .checked_sub(reserves.1)\n            .ok_or(PairError::SubUnderFlow2)?;\n\n        let fee_on = self._mint_fee(reserves.0, reserves.1)?;\n        let total_supply = self.data::<psp22::Data>().supply;\n\n        let liquidity;\n        if total_supply == 0 {\n            let liq = amount_0\n                .checked_mul(amount_1)\n                .ok_or(PairError::MulOverFlow1)?;\n            liquidity = sqrt(liq)\n                .checked_sub(MINIMUM_LIQUIDITY)\n                .ok_or(PairError::SubUnderFlow3)?;\n            self._mint_to(ZERO_ADDRESS.into(), MINIMUM_LIQUIDITY)?;\n        } else {\n            let liquidity_1 = amount_0\n                .checked_mul(total_supply)\n                .ok_or(PairError::MulOverFlow2)?\n                .checked_div(reserves.0)\n                .ok_or(PairError::DivByZero1)?;\n            let liquidity_2 = amount_1\n                .checked_mul(total_supply)\n                .ok_or(PairError::MulOverFlow3)?\n                .checked_div(reserves.1)\n                .ok_or(PairError::DivByZero2)?;\n            liquidity = min(liquidity_1, liquidity_2);\n        }\n\n        if liquidity == 0 {\n            return Err(PairError::InsufficientLiquidityMinted)\n        }\n\n        self._mint_to(to, liquidity)?;\n\n        self._update(balance_0, balance_1, reserves.0, reserves.1)?;\n\n        if fee_on {\n            let k = reserves\n                .0\n                .checked_mul(reserves.1)\n                .ok_or(PairError::MulOverFlow5)?;\n            self.data::<data::Data>().k_last = k;\n        }\n\n        self._emit_mint_event(Self::env().caller(), amount_0, amount_1);\n\n        Ok(liquidity)\n    }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Add the empty implementation of ",(0,r.jsx)(n.strong,{children:"_emit_mint_event"})," and ",(0,r.jsx)(n.strong,{children:"_emit_sync_event"})," in the Pair impl. It should have the ",(0,r.jsx)(n.code,{children:"default"})," keyword as we will override those functions in the Pair contract."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"    default fn _emit_mint_event(&self, _sender: AccountId, _amount_0: Balance, _amount_1: Balance) {}\n\n    default fn _emit_sync_event(&self, _reserve_0: Balance, _reserve_1: Balance) {}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"default"})," keyword needs to have the attribute ",(0,r.jsx)(n.code,{children:"min_specialization"})," added in ",(0,r.jsx)(n.strong,{children:"./logics/lib.rs"})," :"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'#![cfg_attr(not(feature = "std"), no_std)]\n#![feature(min_specialization)]\n'})}),"\n",(0,r.jsx)(n.h3,{id:"5-implement-event",children:"5. Implement Event"}),"\n",(0,r.jsxs)(n.p,{children:["in the contracts ",(0,r.jsx)(n.em,{children:"./cotnracts/pair/lib.rs"})," file, add the Event struct and override the implementation of emit event:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"...\n#[ink(event)]\npub struct Mint {\n    #[ink(topic)]\n    pub sender: AccountId,\n    pub amount_0: Balance,\n    pub amount_1: Balance,\n}\n...\nimpl Pair for PairContract {\n    fn _emit_mint_event(&self, sender: AccountId, amount_0: Balance, amount_1: Balance) {\n        self.env().emit_event(Mint {\n            sender,\n            amount_0,\n            amount_1,\n        })\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Don't forget to add ",(0,r.jsx)(n.code,{children:"overflow-checks = false"})," in your pair ",(0,r.jsx)(n.code,{children:"Cargo.toml"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:"[profile.dev]\noverflow-checks = false\n\n[profile.release]\noverflow-checks = false\n"})}),"\n",(0,r.jsx)(n.p,{children:"And that's it! In these examples we have created a wrapper around a Trait that performs cross-contract calls, which is an advanced Rust & ink! implementation.\nCheck your Pair contract with (run in contract folder):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-console",children:"cargo contract build\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It should now look like this ",(0,r.jsx)(n.a,{href:"https://github.com/AstarNetwork/wasm-tutorial-dex/tree/tutorial/mint_end",children:"branch"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>s});var r=t(67294);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);