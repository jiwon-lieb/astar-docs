"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[6254],{90848:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var i=n(85893),s=n(11151);const a={},r="XVM",c={id:"build/EVM/precompiles/xvm",title:"XVM",description:"The XVM Precompile provides an interface for EVM to call into XVM.",source:"@site/docs/build/EVM/precompiles/xvm.md",sourceDirName:"build/EVM/precompiles",slug:"/build/EVM/precompiles/xvm",permalink:"/docs/build/EVM/precompiles/xvm",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/EVM/precompiles/xvm.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"XC20",permalink:"/docs/build/EVM/precompiles/xc20"},next:{title:"Contract Environment",permalink:"/docs/build/EVM/infra/"}},o={},l=[{value:"Input parameters",id:"input-parameters",level:3},{value:"Output data",id:"output-data",level:3}];function d(e){const t={a:"a",code:"code",h1:"h1",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"xvm",children:"XVM"}),"\n",(0,i.jsx)(t.p,{children:"The XVM Precompile provides an interface for EVM to call into XVM."}),"\n",(0,i.jsx)(t.p,{children:"XVM is designed to be a communication layer and universal execution engine on Astar Network. The idea being that it provides an abstract execution environment which can be used by different execution engines to seamlessly interact with one another. For example, XVM allows EVM smart contract written in Solidity to call into WebAssembly smart contracts written in ink! and vice versa."}),"\n",(0,i.jsx)(t.p,{children:"Please note that XVM is still in its alpha."}),"\n",(0,i.jsx)(t.h1,{id:"call-api",children:"Call API"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"    function xvm_call(\n        bytes calldata context,\n        bytes calldata to,\n        bytes calldata input,\n    ) external returns (bool success, bytes memory data);\n"})}),"\n",(0,i.jsx)(t.p,{children:"Since the interface is abstract and extensible, and each VM treats its parameters differently, the only way to provide a future-proof API is to use byte strings. Under the hood it uses XVM Codec based on SCALE."}),"\n",(0,i.jsx)(t.h3,{id:"input-parameters",children:"Input parameters"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"context"})," is a set of data built by caller that is specific to a particular execution environment. Depending on a VM it may contain the id of a virtual machine and its exexcution environment, gas limits and execution tickets, apparent value, continuation info and other information."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"to"})," is an abstraction of an address, anything can be viewed as a destination of a XVM call"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"input"})," is a SCALE encoded input parameters specific to this particular call which is created by a sender"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"output-data",children:"Output data"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"success"})," is a boolean outcome flag. If ",(0,i.jsx)(t.code,{children:"true"}),", then XVM call was dispatched successfully and ",(0,i.jsx)(t.code,{children:"data"})," contains data returned from the callee. If ",(0,i.jsx)(t.code,{children:"false"}),", then ",(0,i.jsx)(t.code,{children:"data"})," contains error data. In both cases, the contents and the format of ",(0,i.jsx)(t.code,{children:"data"})," are specific to a particular backend. For EVM is would typically be Keccac, for Wasm it would be SCALE."]}),"\n",(0,i.jsx)(t.p,{children:"Please note that this is a low-level interface that is not expected to be used directly. Instead, library authors use such an API to build idiomatic wrappers for specific execution environments."}),"\n",(0,i.jsxs)(t.p,{children:["For example, ",(0,i.jsx)(t.a,{href:"https://github.com/AstarNetwork/ink-xvm-sdk",children:"ink! XVM SDK"})," uses this API to provide XVM functionality for smart contracts written in ink!:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"    #[ink(message)]\n    pub fn claim(&mut self) -> bool {\n        let to = [0xffu8; 20];\n        let value = 424242u128;\n        self.erc20.transfer(to, value)\n    }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In this example we can see that an ink message is created that seamlessly calls into an ERC20 contract that resides in EVM. In its implementation it uses ",(0,i.jsx)(t.code,{children:"xvm_call"})," to dispatch the call."]}),"\n",(0,i.jsx)(t.h1,{id:"notes",children:"Notes"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["In future, the XVM API will be be extended to support asynchronous methods like ",(0,i.jsx)(t.code,{children:"xvm_query"})," and ",(0,i.jsx)(t.code,{children:"xvm_send"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"Currently the API does not support nested XVM calls."}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>c,a:()=>r});var i=n(67294);const s={},a=i.createContext(s);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);