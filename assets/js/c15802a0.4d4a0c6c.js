"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[5594],{17093:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var r=n(85893),o=n(11151);const s={},i="Events",a={id:"tutorials/from-zero-to-ink-hero/nft/Events/events",title:"Events",description:"The last thing our contract will need at this point is an event handler.",source:"@site/docs/tutorials/from-zero-to-ink-hero/nft/Events/events.md",sourceDirName:"tutorials/from-zero-to-ink-hero/nft/Events",slug:"/tutorials/from-zero-to-ink-hero/nft/Events/",permalink:"/docs/tutorials/from-zero-to-ink-hero/nft/Events/",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/tutorials/from-zero-to-ink-hero/nft/Events/events.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"PayableMint Trait Implementation",permalink:"/docs/tutorials/from-zero-to-ink-hero/nft/PayableMintImpl/"},next:{title:"Prerequisites",permalink:"/docs/tutorials/from-zero-to-ink-hero/manic-minter/"}},c={},d=[{value:"What are Events for Smart Contracts?",id:"what-are-events-for-smart-contracts",level:2},{value:"Minting Event",id:"minting-event",level:2},{value:"Update Unit Test",id:"update-unit-test",level:2},{value:"Next Step",id:"next-step",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"events",children:"Events"}),"\n",(0,r.jsx)(t.p,{children:"The last thing our contract will need at this point is an event handler."}),"\n",(0,r.jsx)(t.h2,{id:"what-are-events-for-smart-contracts",children:"What are Events for Smart Contracts?"}),"\n",(0,r.jsx)(t.p,{children:"Events are important for smart contracts because they facilitate communication between the contract itself and the user interface. In traditional Web2 development, a server response is provided in a callback to the frontend. In Web3, when a transaction is executed, smart contracts emit events to the blockchain that the frontend is able to process."}),"\n",(0,r.jsx)(t.h2,{id:"minting-event",children:"Minting Event"}),"\n",(0,r.jsxs)(t.p,{children:["In our contract, an event should be emitted when a token is minted.\nOne could expect that by calling the Openbrush ",(0,r.jsx)(t.code,{children:"_mint_to()"})," function an event will be emitted, but upon closer examination we can see that ",(0,r.jsx)(t.code,{children:"_emit_transfer_event()"})," has an empty default ",(0,r.jsx)(t.a,{href:"https://github1s.com/Supercolony-net/openbrush-contracts/blob/main/contracts/src/token/psp34/psp34.rs#L151-L152",children:"implementation"}),". This grants developers flexibility to create events that are suitable for their own needs."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"default fn _emit_transfer_event(&self, _from: Option<AccountId>, _to: Option<AccountId>, _id: Id) {}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Let's define two events that are required for token handling, ",(0,r.jsx)(t.em,{children:"Transfer"})," and ",(0,r.jsx)(t.em,{children:"Approve"}),", in the contracts's ",(0,r.jsx)(t.code,{children:"lib.rs"})," file. Please note that there is no ",(0,r.jsx)(t.code,{children:"Mint"})," event, as it's covered by the ",(0,r.jsx)(t.em,{children:"Transfer"})," event, in which case ",(0,r.jsx)(t.code,{children:"from"})," will be the contract address."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"use ink::codegen::{EmitEvent, Env};\n\n/// Event emitted when a token transfer occurs.\n#[ink(event)]\npub struct Transfer {\n    #[ink(topic)]\n    from: Option<AccountId>,\n    #[ink(topic)]\n    to: Option<AccountId>,\n    #[ink(topic)]\n    id: Id,\n}\n\n/// Event emitted when a token approve occurs.\n#[ink(event)]\npub struct Approval {\n    #[ink(topic)]\n    from: AccountId,\n    #[ink(topic)]\n    to: AccountId,\n    #[ink(topic)]\n    id: Option<Id>,\n    approved: bool,\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Override the default event emission function:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[overrider(psp34::Internal)]\nfn _emit_transfer_event(&self, from: Option<AccountId>, to: Option<AccountId>, id: Id) {\n    self.env().emit_event(Transfer { from, to, id });\n}\n\n#[overrider(psp34::Internal)]\nfn _emit_approval_event(&self, from: AccountId, to: AccountId, id: Option<Id>, approved: bool) {\n    self.env().emit_event(Approval {\n        from,\n        to,\n        id,\n        approved,\n    });\n}\n"})}),"\n",(0,r.jsx)(t.h2,{id:"update-unit-test",children:"Update Unit Test"}),"\n",(0,r.jsx)(t.p,{children:"As a final check let's add an event check at the end of our unit test. Since our test minted 5 tokens, we should expect 5 events to be emitted."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"assert_eq!(5, ink::env::test::recorded_events().count());\n"})}),"\n",(0,r.jsx)(t.p,{children:"Format your code with:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"cargo fmt --all\n"})}),"\n",(0,r.jsx)(t.p,{children:"Run unit test:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"cargo test\n"})}),"\n",(0,r.jsxs)(t.p,{children:["At this stage, your code should look something like ",(0,r.jsx)(t.a,{href:"https://github.com/swanky-dapps/nft/tree/tutorial/events",children:"this"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"next-step",children:"Next Step"}),"\n",(0,r.jsx)(t.p,{children:"Congratulations! You've made it through all the steps required to build your NFT Contract!"}),"\n",(0,r.jsxs)(t.p,{children:["As a next step, review the code in the ",(0,r.jsx)(t.a,{href:"https://github.com/swanky-dapps/nft/",children:"main"})," branch for the repository used for this tutorial. There you can enhance your knowledge about:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Improving the unit test coverage."}),"\n",(0,r.jsx)(t.li,{children:"Adding new useful functions."}),"\n",(0,r.jsx)(t.li,{children:"End-to-end testing."}),"\n",(0,r.jsx)(t.li,{children:"Improving error handling."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>i});var r=n(67294);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);