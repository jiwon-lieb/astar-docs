"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[8264],{87988:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});var s=n(85893),a=n(11151);const r={},l="XVM",i={id:"learn/interoperability/xvm/index",title:"XVM",description:"Note that at this time XVM features are only launched in Shibuya testnet. Stay tuned for Shiden and Astar!",source:"@site/docs/learn/interoperability/xvm/index.md",sourceDirName:"learn/interoperability/xvm",slug:"/learn/interoperability/xvm/",permalink:"/docs/learn/interoperability/xvm/",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/learn/interoperability/xvm/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"FAQ",permalink:"/docs/learn/interoperability/xcm/faq"},next:{title:"Astar zkEVM",permalink:"/docs/learn/zkEVM/"}},c={},o=[{value:"Intro: Multiple VMs as one; one VM for all",id:"intro-multiple-vms-as-one-one-vm-for-all",level:2},{value:"Architecture",id:"architecture",level:2},{value:"Components",id:"components",level:3},{value:"Cross-VM calls",id:"cross-vm-calls",level:3},{value:"Interfaces",id:"interfaces",level:3},{value:"<code>input</code> encoding",id:"input-encoding",level:4},{value:"Gaps between EVM and Wasm contracts",id:"gaps-between-evm-and-wasm-contracts",level:4},{value:"Error handling",id:"error-handling",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"xvm",children:"XVM"}),"\n",(0,s.jsx)(t.p,{children:"Note that at this time XVM features are only launched in Shibuya testnet. Stay tuned for Shiden and Astar!"}),"\n",(0,s.jsx)(t.h2,{id:"intro-multiple-vms-as-one-one-vm-for-all",children:"Intro: Multiple VMs as one; one VM for all"}),"\n",(0,s.jsx)(t.p,{children:"As a smart contract platform, Astar Network currently supports both EVM and Wasm (WebAssembly) contracts. Based on specific needs, developers are free to build on either VM. This brings both flexibility for builders and larger groups of users to Astar Network. But the Astar team doesn\u2019t just stop there. Even better, our multi-VM solution, XVM, is introduced to bring true interoperability between different VMs."}),"\n",(0,s.jsx)(t.p,{children:"XVM allows smart contracts in different VMs to work together seamlessly. A smart contract in EVM can call a Wasm contract just like it\u2019s another EVM contract and verse visa. From either EVM or Wasm perspective, contracts in different VMs can work together like they are in one: the XVM."}),"\n",(0,s.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"XVM.png",src:n(3416).Z+"",width:"2781",height:"2181"})}),"\n",(0,s.jsx)(t.h3,{id:"components",children:"Components"}),"\n",(0,s.jsx)(t.p,{children:"The XVM architecture contains five main components:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"pallet-xvm"}),": the hub module to call EVM or Wasm."]}),"\n",(0,s.jsxs)(t.li,{children:["XVM precompile: a custom precompile that allows EVM contracts to call ",(0,s.jsx)(t.code,{children:"pallet-xvm"})," ."]}),"\n",(0,s.jsxs)(t.li,{children:["Chain extension: the interface that allows ink! contracts to call ",(0,s.jsx)(t.code,{children:"pallet-xvm"})]}),"\n",(0,s.jsx)(t.li,{children:"EVM: Astar EVM implementation, which is Ethereum compatible."}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"pallet-contracts"}),": the VM for ink! smart contracts."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"pallet-xvm"})," module is the core part of XVM. It provides functions to allow other components to call EVM or Wasm, while ",(0,s.jsx)(t.em,{children:"XVM precompile"})," and ",(0,s.jsx)(t.em,{children:"chain extension"})," play the role of gateways for contracts to call the ",(0,s.jsx)(t.code,{children:"pallet-xvm"})," module."]}),"\n",(0,s.jsx)(t.h3,{id:"cross-vm-calls",children:"Cross-VM calls"}),"\n",(0,s.jsx)(t.p,{children:"A typical XVM cross-VM call could be either:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Call from EVM into Wasm, or"}),"\n",(0,s.jsx)(t.li,{children:"Call from Wasm into EVM"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["For calls from EVM into Wasm, the call will be initiated by smart contracts in EVM. The call path is: EVM contract -> precompile -> ",(0,s.jsx)(t.code,{children:"pallet-xvm"})," -> Wasm."]}),"\n",(0,s.jsxs)(t.p,{children:["For calls from Wasm into EVM, the call will be initiated by smart contracts in Wasm. The call path is: Wasm contract -> chain extension -> ",(0,s.jsx)(t.code,{children:"pallet-xvm"})," -> EVM."]}),"\n",(0,s.jsx)(t.p,{children:"Note that only calling from one VM to another is allowed. Calling the contracts within the same VM will be reverted with an error."}),"\n",(0,s.jsx)(t.h3,{id:"interfaces",children:"Interfaces"}),"\n",(0,s.jsx)(t.p,{children:"For Solidity EVM contracts, the XVM interface is defined as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-solidity",children:"interface XVM {\n    function xvm_call(\n        uint8 vm_id,\n        bytes calldata to,\n        bytes calldata input,\n        uint256 value,\n        uint256 storage_deposit_limit\n    ) external payable returns (bool success, bytes memory data);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["For ink! Wasm contracts, XVM can be called with ",(0,s.jsx)(t.em,{children:"chain extension"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub type CallResult = u32;\n\n#[ink::chain_extension]\npub trait XvmCall {\n    type ErrorCode = u32;\n\n    #[ink(extension = 0x00010001, handle_status = false)]\n    fn call(vm_id: u8, target: Vec<u8>, input: Vec<u8>, value: u128) -> CallResult;\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"EVM and Wasm contracts have a similar interface for XVM calls. The common arguments they share:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"vm_id"}),": ID of the target VM to call. Use ",(0,s.jsx)(t.code,{children:"0x0F"})," to call EVM and ",(0,s.jsx)(t.code,{children:"0x1F"})," to call Wasm."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"to"}),": the address of the target contract. For EVM contracts, it\u2019s a ",(0,s.jsx)(t.code,{children:"H160"})," bytes. For Wasm it\u2019s ",(0,s.jsx)(t.code,{children:"AccountId32"})," bytes."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"input"}),": the encoded call arguments."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"value"}),": the amount of native token to transfer, used for payable calls."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Note that in the context of caller VM, the caller address is always the address of the caller contract, instead of the user address. For instance, Alice calls an EVM smart contract ",(0,s.jsx)(t.code,{children:"ContractA"})," that calls into an ink! contract, within the ink! contract\u2019s call, the ",(0,s.jsx)(t.code,{children:"self.env.caller"})," is ",(0,s.jsx)(t.code,{children:"ContractA"})," address instead of Alice."]}),"\n",(0,s.jsxs)(t.h4,{id:"input-encoding",children:[(0,s.jsx)(t.code,{children:"input"})," encoding"]}),"\n",(0,s.jsxs)(t.p,{children:["As mentioned above, ",(0,s.jsx)(t.code,{children:"input"})," of encoded arguments is needed for XVM calls. The encoding specification depends on which VM to call."]}),"\n",(0,s.jsxs)(t.p,{children:["For calls to EVM (",(0,s.jsx)(t.code,{children:"0x0F"})," as VM Id), refer to ",(0,s.jsx)(t.a,{href:"https://docs.soliditylang.org/en/latest/abi-spec.html#function-selector-and-argument-encoding",children:"here"})," for Solidity ABI specifications and ",(0,s.jsx)(t.a,{href:"https://docs.soliditylang.org/en/latest/abi-spec.html#examples",children:"here"})," for examples."]}),"\n",(0,s.jsxs)(t.p,{children:["For calls to Wasm (",(0,s.jsx)(t.code,{children:"0x1F"})," as VM Id), the ",(0,s.jsx)(t.code,{children:"input"})," is encoded as: ",(0,s.jsx)(t.code,{children:"selector_bytes ++ scale_encoded_args"}),"."]}),"\n",(0,s.jsx)(t.h4,{id:"gaps-between-evm-and-wasm-contracts",children:"Gaps between EVM and Wasm contracts"}),"\n",(0,s.jsxs)(t.p,{children:["In the case of calling from EVM to Wasm, to call XVM in EVM, an extra parameter ",(0,s.jsx)(t.code,{children:"storage_deposit_limit"})," is needed. It is required by ",(0,s.jsx)(t.code,{children:"pallet-contracts"}),", to specify the maximum storage deposit to pay storage rent. As mentioned above, as the caller\u2019s address is always a contract address instead of a user, it\u2019s the caller contract\u2019s address that pays for the storage rent. For Solidity contracts that call Wasm contracts via XVM, developers need to make sure the contract has enough balance for the payment, or the call fails. To pass a sufficient ",(0,s.jsx)(t.code,{children:"storage_deposit_limit"})," value, developers need to know how much is required from the caller contract. For instance, they can benchmark the target call and get the limit in worst-case scenario ",(0,s.jsx)(t.code,{children:"N"}),", and pass ",(0,s.jsx)(t.code,{children:"2 x N"})," for margin of safety."]}),"\n",(0,s.jsxs)(t.p,{children:["Another worth mentioning gap for payable calls from EVM to Wasm is the concept of ",(0,s.jsx)(t.em,{children:"ED(existential deposit)"})," in ",(0,s.jsx)(t.code,{children:"pallet-contracts"}),". Using the ",(0,s.jsx)(t.code,{children:"pallet-balances"})," in Substrate for payable calls, ",(0,s.jsx)(t.code,{children:"pallet-contracts"})," assumes all addresses, including EVM contracts address, need to meet the minimum balance requirement to keep alive (which is not true as there are no ED requirements in EVM). As mentioned above, the caller address is always the calling contract, for payable calls from EVM to Wasm, developers need to make sure their EVM contract address meets the ED requirement, otherwise, the payable call will fail in Wasm and be reverted."]}),"\n",(0,s.jsx)(t.h3,{id:"error-handling",children:"Error handling"}),"\n",(0,s.jsx)(t.p,{children:"The errors incurred in XVM calls bubble up from the caller VM to the caller VM. If an error is returned in either EVM or Wasm, the whole XVM call will be reverted."})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},3416:(e,t,n)=>{n.d(t,{Z:()=>s});const s=n.p+"assets/images/xvm-architecture-8913b73ed535de304db5165978b85f3e.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>l});var s=n(67294);const a={},r=s.createContext(a);function l(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);