"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[6218],{42825:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=t(85893),o=t(11151);const a={sidebar_position:1},s="Band Protocol VRF",i={id:"build/integrations/vrf/band",title:"Band Protocol VRF",description:"[Band VRF]//bandprotocol.com/vrf",source:"@site/docs/build/integrations/vrf/band.md",sourceDirName:"build/integrations/vrf",slug:"/build/integrations/vrf/band",permalink:"/docs/build/integrations/vrf/band",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/integrations/vrf/band.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"DIA Wasm Oracle",permalink:"/docs/build/integrations/oracles/dia-wasm"},next:{title:"Node Operators",permalink:"/docs/build/nodes/"}},d={},l=[{value:"Overview",id:"overview",level:2},{value:"Integrate with Band VRF",id:"integrate-with-band-vrf",level:2},{value:"Step 1: Prepare a VRF Consumer Contract",id:"step-1-prepare-a-vrf-consumer-contract",level:3},{value:"Step 2: Choose a resolving method",id:"step-2-choose-a-resolving-method",level:3},{value:"Step 3: Request a Random Value",id:"step-3-request-a-random-value",level:3},{value:"Contract Addresses",id:"contract-addresses",level:2},{value:"Example Usage",id:"example-usage",level:2},{value:"Full Documentation",id:"full-documentation",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"band-protocol-vrf",children:"Band Protocol VRF"}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://bandprotocol.com/vrf",children:"Band VRF"})," provides a verifiable pseudorandomness solution based on the BandChain blockchain. Our protocol uses a Verifiable Random Function (VRF) to cryptographically secure and verify that output results have not and cannot be tampered with."]}),"\n",(0,r.jsx)(n.p,{children:"Similar to the BandChain Oracle Network, the Band VRF is a VRF system that serves requests from dApps. Validators on the BandChain and the VRF Oracle Script are responsible for generating the random number requests that are verifiably random. Final validated results are stored on the BandChain as proof of the random number generation process before returning the results to the requested dApps."}),"\n",(0,r.jsx)(n.h2,{id:"integrate-with-band-vrf",children:"Integrate with Band VRF"}),"\n",(0,r.jsxs)(n.p,{children:["This guide serves as a quick reference about how to request random data from the Band VRF. For a more detailed reference with examples, refer to the ",(0,r.jsx)(n.a,{href:"https://docs.bandchain.org/vrf/vrf-integration.html",children:"VRF Integration"})," section."]}),"\n",(0,r.jsx)(n.h3,{id:"step-1-prepare-a-vrf-consumer-contract",children:"Step 1: Prepare a VRF Consumer Contract"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Create a VRF consumer contract that can call the ",(0,r.jsx)(n.code,{children:"requestRandomData"})," function on the ",(0,r.jsx)(n.code,{children:"VRFProvider"})," contract."]}),"\n",(0,r.jsxs)(n.li,{children:["Implement a callback function (e.g. ",(0,r.jsx)(n.code,{children:"consume"}),") on the VRF consumer contract, which allows the ",(0,r.jsx)(n.code,{children:"VRFProvider"})," contract to call back and execute some logic against the returned result. It is critical that this callback function can only be called by the ",(0,r.jsx)(n.code,{children:"VRFProvider"})," contract."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-2-choose-a-resolving-method",children:"Step 2: Choose a resolving method"}),"\n",(0,r.jsx)(n.p,{children:"There are currently 3 methods for relaying and resolving the VRF request:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Band's VRF worker solution"})," - We provide both standard and customized solutions for all clients. Visit ",(0,r.jsx)(n.a,{href:"mailto:bd@bandprotolcol.com",children:"contact us"})," for more details."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manually resolve on CosmoScan"})," - This is an ideal and low cost solution for one-off Band VRF requests. Refer to this ",(0,r.jsx)(n.a,{href:"https://docs.bandchain.org/vrf/vrf-integration.html#manually-request-and-resolve",children:"guide"})," for how to resolve manually."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement your own resolver bot"})," - Anyone can implement their own version of resolver bot. An open-source version of Band's VRF worker bot will be available soon."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"step-3-request-a-random-value",children:"Step 3: Request a Random Value"}),"\n",(0,r.jsx)(n.p,{children:"You are now ready to request a random value from the Band VRF."}),"\n",(0,r.jsx)(n.p,{children:"A summary of the Band VRF process is outlined below:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Simply call the request function on your VRF consumer contract that implements the ",(0,r.jsx)(n.code,{children:"requestRandomData"})," function in Step 1, providing a ",(0,r.jsx)(n.code,{children:"seed"})," and an optional ",(0,r.jsx)(n.code,{children:"msg.value"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"Depending on the resolving method chosen in Step 2, the request is sent to the BandChain."}),"\n",(0,r.jsx)(n.li,{children:"The VRF oracle script on the BandChain forwards the request to a randomly chosen data source, and then retrieves the returned result and the corresponding proof of authenticity."}),"\n",(0,r.jsxs)(n.li,{children:["Depending on the resolving method chosen in Step 2, the proof is relayed to the ",(0,r.jsx)(n.code,{children:"Bridge"})," contract for verification on the client chain via the ",(0,r.jsx)(n.code,{children:"VRFProvider"})," contract."]}),"\n",(0,r.jsx)(n.li,{children:"If the verification succeeds, the result (random value) is returned to the VRF consumer contract via the callback function mentioned in Step 1."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"contract-addresses",children:"Contract Addresses"}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.code,{children:"VRFProvider"})," and other contract addresses on Astar, please refer to the ",(0,r.jsx)(n.a,{href:"https://docs.bandchain.org/vrf/supported-blockchains.html",children:"Supported Blockchains"})," section."]}),"\n",(0,r.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,r.jsx)(n.p,{children:"The contract below is an example of a simple VRF consumer contract written in Solidity."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:'contract MockVRFConsumer {\n    IVRFProvider public provider;\n    string public latestSeed;\n    uint64 public latestTime;\n    bytes32 public latestResult;\n\n    constructor(IVRFProvider _provider) {\n        provider = _provider;\n    }\n\n    function requestRandomDataFromProvider(string calldata seed) external payable {\n        provider.requestRandomData{value: msg.value}(seed);\n    }\n    \n    function consume(string calldata seed, uint64 time, bytes32 result) external override {\n        require(msg.sender == address(provider), "Caller is not the provider");\n        \n        latestSeed = seed;\n        latestTime = time;\n        latestResult = result;\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["More complex and detailed examples can be found in the ",(0,r.jsx)(n.a,{href:"https://docs.bandchain.org/vrf/example.html",children:"Example Use Cases"})," section."]}),"\n",(0,r.jsx)(n.h2,{id:"full-documentation",children:"Full Documentation"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://docs.bandchain.org/vrf/introduction.html",children:"Band VRF Documentation"})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>s});var r=t(67294);const o={},a=r.createContext(o);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);