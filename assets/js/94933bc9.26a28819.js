"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[5871],{33125:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=t(85893),s=t(11151);const i={sidebar_position:9},r="Client Applications",o={id:"learn/interoperability/xcm/building-with-xcm/client-applications",title:"Client Applications",description:"In this chapter, we will examine how to use TypeScript to interact with the XCM pallet and construct XCM transactions. Using this information, you will be able to create an XCM dApp, or bridge.",source:"@site/docs/learn/interoperability/xcm/building-with-xcm/client-applications.md",sourceDirName:"learn/interoperability/xcm/building-with-xcm",slug:"/learn/interoperability/xcm/building-with-xcm/client-applications",permalink:"/docs/learn/interoperability/xcm/building-with-xcm/client-applications",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/learn/interoperability/xcm/building-with-xcm/client-applications.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Withdraw Assets",permalink:"/docs/learn/interoperability/xcm/building-with-xcm/xc-assets-withdraw"},next:{title:"FAQ for Smart Contracts",permalink:"/docs/learn/interoperability/xcm/building-with-xcm/faq-for-smart-contracts"}},c={},l=[];function h(n){const e={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",...(0,s.a)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"client-applications",children:"Client Applications"}),"\n",(0,a.jsx)(e.p,{children:"In this chapter, we will examine how to use TypeScript to interact with the XCM pallet and construct XCM transactions. Using this information, you will be able to create an XCM dApp, or bridge."}),"\n",(0,a.jsxs)(e.p,{children:["While interacting with the XCM pallet via the Substrate RPC, we will make use of the ",(0,a.jsx)(e.a,{href:"https://github.com/polkadot-js/api",children:(0,a.jsx)(e.code,{children:"polkadot/api"})})," package, throughout this chapter."]}),"\n",(0,a.jsx)(e.p,{children:"First, you will need to initialize the API as you would with any Substrate application."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst myApp = async () => {\n    const provider = new WsProvider('wss://rpc.shiden.astar.network');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n  const paraId = await chainApi.query.parachainInfo.parachainId.toString();\n \n  // Should output 2007\n  console.log(paraId)\n};\n"})}),"\n",(0,a.jsxs)(e.p,{children:["On Astar Network, we use the ",(0,a.jsx)(e.a,{href:"https://github.com/paritytech/substrate/tree/master/frame/assets",children:"Substrate Assets pallet"})," to handle the XCM multi-asset representation. Let\u2019s retrieve the list of assets from the network."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:" \n// import the known types\nimport { AssetMetadata, AssetDetails } from '@polkadot/types/interfaces';\n\n// we create a custom interface for convenience\ninterface ChainAsset extends AssetDetails {\n    id: string;\n    metadata: AssetMetadata;\n}\n\n  //...snip\n\n  // note that this function requires the chain to implement the Assets pallet\n\n    // note: The asset ID will have different meanings depending on the range\n    // 1 ~ 2^32-1 = User-defined assets. Anyone can register this assets on chain.\n    // 2^32 ~ 2^64-1 = Statemine/Statemint assets map. This is a direct map of all the assets stored in the common-goods state chain.\n    // 2^64 ~ 2^128-1 = Ecosystem assets like native assets on another parachain or other valuable tokens.\n    // 2^128 ~ 1 = Relaychain native token (DOT or KSM).\n\n    const assetsListRaw = await chainApi.query.assets.asset.entries();\n    const assetMetadataListRaw = await chainApi.query.assets.metadata.entries();\n\n    const assetInfos = assetsListRaw.map((i, index) => {\n        const assetId = (i[0].toHuman() as string[])[0].replaceAll(',', '');\n        const assetInfo = i[1].toHuman() as any as AssetDetails;\n        const metadata = assetMetadataListRaw[index][1].toHuman() as any as AssetMetadata;\n        return {\n            id: assetId,\n            ...assetInfo,\n            metadata,\n        } as ChainAsset;\n    });\n    // convert the list into a string array of numbers without the comma and no nested entries\n};\n"})}),"\n",(0,a.jsx)(e.p,{children:"Running this function will produce a list of assets that are registered on the chain. This is useful when you want to create a UI that lists all possible assets, including XCM-compatible assets."}),"\n",(0,a.jsxs)(e.p,{children:["Next, let\u2019s execute a cross-consensus function. Parachains will have a pallet called ",(0,a.jsx)(e.code,{children:"polkadotXcm"}),", while Relay Chains will use the pallet ",(0,a.jsx)(e.code,{children:"xcmPallet"}),". Both of them will use the same functions and syntax for sending XCM transactions."]}),"\n",(0,a.jsx)(e.p,{children:"In this example, we will send the Relay Chain asset to the parachain, as we've done in previous chapters, but this time, we\u2019ll use TypeScript."}),"\n",(0,a.jsx)(e.p,{children:"Let\u2019s create two API instances, one for the parachain and another for the Relay Chain. Although for our example, we will only call the extrinsic from the Relay Chain, and initialize the parachain API instance to dynamically obtain the parachain ID."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Vec, u32 } from '@polkadot/types';\n\nconst parachainApi = async () => {\n    const provider = new WsProvider('wss://rpc.shiden.astar.network');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n    const paraId = (await chainApi.query.parachainInfo.parachainId()).toString();\n\n    // Should output 2007\n    console.log(paraId);\n    return chainApi;\n};\n\nconst relaychainApi = async () => {\n    const provider = new WsProvider('wss://kusama-rpc.polkadot.io');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n    const parachains = ((await chainApi.query.paras.parachains()) as Vec<u32>).map((i) => i.toNumber());\n\n    // Should output a list of parachain IDs\n    console.log(parachains);\n    return chainApi;\n};\n"})}),"\n",(0,a.jsx)(e.p,{children:"Next, we create the main function for handling the actual XCM transaction."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"import { Keyring } from '@polkadot/keyring';\nimport { decodeAddress, cryptoWaitReady } from '@polkadot/util-crypto';\n\nconst myApp = async () => {\n  await cryptoWaitReady();\n\n    const keyring = new Keyring({ type: 'sr25519' });\n    // ensure that this account has some KSM\n    const account = keyring.addFromUri('account seed', { name: 'Default' }, 'sr25519');\n\n    const parachainApiInst = await parachainApi();\n    const relaychainApiInst = await relaychainApi();\n\n    const parachainId = await parachainApiInst.query.parachainInfo.parachainId.toString();\n    \n    // the target parachain connected to the current relaychain\n    const dest = {\n        V1: {\n            interior: {\n                X1: {\n                    Parachain: parachainId,\n                },\n            },\n            parents: 0,\n        },\n    };\n    // the account ID within the destination parachain\n    const beneficiary = {\n        V1: {\n            interior: {\n                X1: {\n                    AccountId32: {\n                        network: 'Any',\n                        id: decodeAddress(account.address),\n                    },\n                },\n            },\n            parents: 0,\n        },\n    };\n\n  // 1 KSM\n    const amountToSend = new BN(10).pow(new BN(12));\n    // amount of fungible tokens to be transferred\n    const assets = {\n        V1: [\n            {\n                fun: {\n                    Fungible: amountToSend,\n                },\n                id: {\n                    Concrete: {\n                        interior: 'Here',\n                        parents: 0,\n                    },\n                },\n            },\n        ],\n    };\n\n    const txHash = await relaychainApiInst.tx.xcmPallet.reserveTransferAssets(dest, beneficiary, assets, 0).signAndSend(account);\n};\n"})}),"\n",(0,a.jsx)(e.p,{children:"To summarize, the first half of the function loads the account that will send the KSM and initialize the API. The real magic happens in the latter half of the function."}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"    // the target parachain connected to the current relaychain\n    const dest = {\n        V1: {\n            interior: {\n                X1: {\n                    Parachain: parachainId,\n                },\n            },\n            parents: 0,\n        },\n    };\n    // the account ID within the destination parachain\n    const beneficiary = {\n        V1: {\n            interior: {\n                X1: {\n                    AccountId32: {\n                        network: 'Any',\n                        id: decodeAddress(account.address),\n                    },\n                },\n            },\n            parents: 0,\n        },\n    };\n\n  // 1 KSM\n    const amountToSend = new BN(10).pow(new BN(12));\n    // amount of fungible tokens to be transferred\n    const assets = {\n        V1: [\n            {\n                fun: {\n                    Fungible: amountToSend,\n                },\n                id: {\n                    Concrete: {\n                        interior: 'Here',\n                        parents: 0,\n                    },\n                },\n            },\n        ],\n    };\n"})}),"\n",(0,a.jsxs)(e.p,{children:["As you can see, the ",(0,a.jsx)(e.code,{children:"dest"})," refers to the destination or target chain that will receive the asset identified by the parachain ID. The ",(0,a.jsx)(e.code,{children:"beneficiary"})," refers to the account within the parachain that will receive the token. Finally, the ",(0,a.jsx)(e.code,{children:"assets"})," parameter refers to the amount you wish to send. Finally, we can sign the transaction with the following function:"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// This can be zero\nconst feeAsset = 0;\nconst txHash = await relaychainApiInst.tx.xcmPallet.reserveTransferAssets(dest, beneficiary, assets, feeAsset).signAndSend(account);\n"})}),"\n",(0,a.jsx)(e.p,{children:"Now once you finish the XCM transaction, you can list all the assets with the following script:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"const assetsListRaw = await parachainApiInst.query.assets.asset.entries();\nconst assetMetadataListRaw = await parachainApiInst.query.assets.metadata.entries();\n\nconst assetInfos = assetsListRaw.map((i, index) => {\n    const assetId = (i[0].toHuman() as string[])[0].replaceAll(',', '');\n    const assetInfo = i[1].toHuman() as any as AssetDetails;\n    const metadata = assetMetadataListRaw[index][1].toHuman() as any as AssetMetadata;\n    return {\n        id: assetId,\n        ...assetInfo,\n        metadata,\n    } as ChainAsset;\n});\n\nconst assetBalance = await Promise.all(assetInfos.map(async (i) => {\n    const balance = await parachainApiInst.query.assets.account(i.id, account.address);\n    return {\n        symbol: i.metadata.symbol.toString(),\n        balance: balance.toString(),\n    }\n}))\n\nconsole.log(assetBalance);\n"})}),"\n",(0,a.jsx)(e.p,{children:"Now, you should be able to transfer the asset from the Relay Chain to the parachain, and check to see if it was successful by listing all the assets within the asset pallet that the current account holds."}),"\n",(0,a.jsxs)(e.p,{children:["Please note that the gas fee will be deducted from the amount transferred, so it should be adjusted accordingly, based on the estimated gas fee. Please refer to the ",(0,a.jsx)(e.a,{href:"https://app.gitbook.com/o/-LgGrgOEDyFYjYWIb1DT/s/-M8GVK5H7hOsGnYqg-7q-872737601/~/changes/aJQFFWQNMjlao1SSjj4a/build/api/gas-price-api",children:"Gas Price API"})," if required, for specific use cases."]}),"\n",(0,a.jsxs)(e.p,{children:["You can find an entire project that integrates similar functionality in ",(0,a.jsx)(e.a,{href:"https://github.com/AstarNetwork/astar-xcm-tools",children:"this repository"}),"."]})]})}function d(n={}){const{wrapper:e}={...(0,s.a)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(h,{...n})}):h(n)}},11151:(n,e,t)=>{t.d(e,{Z:()=>o,a:()=>r});var a=t(67294);const s={},i=a.createContext(s);function r(n){const e=a.useContext(i);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);