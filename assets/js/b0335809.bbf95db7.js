"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[2545],{12396:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var r=n(85893),i=n(11151);const o={},s="File & Folder Structure",a={id:"build/wasm/from-zero-to-ink-hero/dex/Structure/file-structure",title:"File & Folder Structure",description:"Each Contract Should be in its Own Crate",source:"@site/docs/build/wasm/from-zero-to-ink-hero/dex/Structure/file-structure.md",sourceDirName:"build/wasm/from-zero-to-ink-hero/dex/Structure",slug:"/build/wasm/from-zero-to-ink-hero/dex/Structure/file-structure",permalink:"/docs/build/wasm/from-zero-to-ink-hero/dex/Structure/file-structure",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/wasm/from-zero-to-ink-hero/dex/Structure/file-structure.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/docs/build/wasm/from-zero-to-ink-hero/dex/"},next:{title:"Implement PSP22 for Pair",permalink:"/docs/build/wasm/from-zero-to-ink-hero/dex/Pair/psp22"}},l={},c=[{value:"Each Contract Should be in its Own Crate",id:"each-contract-should-be-in-its-own-crate",level:2},{value:"Trait and Generic Implementation in Separate Files",id:"trait-and-generic-implementation-in-separate-files",level:2},{value:"File Structure of the DEX Project",id:"file-structure-of-the-dex-project",level:2},{value:"Resources",id:"resources",level:2}];function d(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"file--folder-structure",children:"File & Folder Structure"}),"\n",(0,r.jsx)(t.h2,{id:"each-contract-should-be-in-its-own-crate",children:"Each Contract Should be in its Own Crate"}),"\n",(0,r.jsxs)(t.p,{children:["ink! uses ",(0,r.jsx)(t.a,{href:"https://use.ink/macros-attributes",children:"macros"})," to define your contract. It is composed of a struct that define your contract storage and implementation of associated methods and functions."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'#![cfg_attr(not(feature = "std"), no_std)]\n\n#[ink::contract]\npub mod contract {\n    #[ink(storage)]\n    pub struct ContractStorage {\n        any_value: bool,\n    }\n\n    impl ContractStorage {\n        #[ink(constructor)]\n        pub fn constructor(init_value: bool) -> Self {\n            Self { any_value: init_value }\n        }\n        \n        #[ink(message)]\n        pub fn callable_method(&mut self) {\n            self.value = !self.value;\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["As defining an inherent ",(0,r.jsx)(t.code,{children:"impl"})," for a type that is external to the crate where the type is defined is not ",(0,r.jsx)(t.a,{href:"https://doc.rust-lang.org/error_codes/E0116.html",children:"supported"}),", we will need to define a Trait in an external crate and implement it, instead. This functionality is supported using the ink! macro ",(0,r.jsx)(t.code,{children:"#[ink::trait_definition]"})," (see ",(0,r.jsx)(t.a,{href:"https://use.ink/basics/trait-definitions/",children:"ink! trait-definitions doc"})," for more information), but has some limitations, and it is not possible to have a default implementation."]}),"\n",(0,r.jsx)(t.p,{children:"Therefore, the only solution, in ink!, is to implement an omnibus contract with all the code in the same file, which will not be easily readable or maintainable."}),"\n",(0,r.jsx)(t.h2,{id:"trait-and-generic-implementation-in-separate-files",children:"Trait and Generic Implementation in Separate Files"}),"\n",(0,r.jsxs)(t.p,{children:["In order to organise the business logic into different files, OpenBrush uses ",(0,r.jsx)(t.a,{href:"https://github.com/rust-lang/rfcs/pull/1210",children:"specialization"})," that permits multiple ",(0,r.jsx)(t.code,{children:"impl"})," blocks to be applied to the same type.",(0,r.jsx)(t.br,{}),"\n","With OpenBrush, you can define as many Trait and generic implementations as are needed, which allows you to split up your code to more easily implement it into your contract. Of course, specialization also allows you to override a default implementation (if the method or impl is specialized with the ",(0,r.jsx)(t.a,{href:"https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md#the-default-keyword",children:(0,r.jsx)(t.code,{children:"default"})})," keyword).",(0,r.jsx)(t.br,{}),"\n","So you define a Trait and a generic implementation in a crate and within the contract you implement this Trait. If this impl block is empty ",(0,r.jsx)(t.code,{children:"{}"})," specialization will implement the most specific implementation, which is the one you defined in the file. Every generic implementation in Openbrush (PSP22, PSP34, ..) uses the ",(0,r.jsx)(t.code,{children:"default"})," keyword that makes these functions ",(0,r.jsx)(t.em,{children:"overrideable"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Define your Trait in a file:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"#[openbrush::trait_definition]\npub trait MyTrait {\n    #[ink(message)]\n    fn method(&self) -> u32;\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"trait.rs"})}),"\n",(0,r.jsx)(t.p,{children:"And a generic implementation in another file:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:"impl MyTrait for T\n{\n    #[ink(message)]\n    fn method(&self) -> u32 {\n        unimplemented!()\n    }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"impl.rs"})}),"\n",(0,r.jsx)(t.p,{children:"And implement it in your contract file:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-rust",children:'#![cfg_attr(not(feature = "std"), no_std)]\n\n#[ink::contract]\npub mod contract {\n    // Import everything from the crate\n    use external_crate::traits::*;\n    #[ink(storage)]\n    pub struct ContractStorage {\n        any_value: bool,\n    }\n    \n    // Implement the Trait\n    // Even if this impl block is empty\n    // Specialization will implement the one defined in the impl.rs file\n    impl MyTrait for ContractStorage {}\n\n    impl ContractStorage {\n        #[ink(constructor)]\n        pub fn constructor(init_value: bool) -> Self {\n            Self { any_value: init_value }\n        }\n        \n        #[ink(message)]\n        pub fn callable_method(&mut self) {\n            self.value = !self.value;\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.em,{children:"lib.rs"})}),"\n",(0,r.jsx)(t.h2,{id:"file-structure-of-the-dex-project",children:"File Structure of the DEX Project"}),"\n",(0,r.jsxs)(t.p,{children:["We will put the Trait and generic implementations in separate files, as described below, when building the DEX.\nThe contracts will be in the ",(0,r.jsx)(t.code,{children:"contracts"})," folder and the Traits & generic implementation will be in the ",(0,r.jsx)(t.code,{children:"logics"})," folder. All of these will be within the same project workspace."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"\u251c\u2500\u2500 uniswap-v2\n\u2502   \u251c\u2500\u2500 contracts\n\u2502   \u2514\u2500\u2500 logics\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 .rustfmt\n\u2514\u2500\u2500 .gitignore\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In the ",(0,r.jsx)(t.code,{children:"contracts"})," folder there should be one folder for each contract, each packaged as crates with their own ",(0,r.jsx)(t.code,{children:"Cargo.toml"})," and ",(0,r.jsx)(t.code,{children:"lib.rs"})," files.",(0,r.jsx)(t.br,{}),"\n","The ",(0,r.jsx)(t.code,{children:"logics"})," folder is a crate which contains a folder for ",(0,r.jsx)(t.code,{children:"traits"})," and another for ",(0,r.jsx)(t.code,{children:"impls"}),".\nInside the ",(0,r.jsx)(t.code,{children:"traits"})," folder there should be one file per contract. Inside the ",(0,r.jsx)(t.code,{children:"impls"})," there should be one folder per contract and inside, one file for the implementation of the trait, and another 'data' file used for storage."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",children:"\u251c\u2500\u2500 logics\n\u2502   \u251c\u2500\u2500 impls\n\u2502   \u2502   \u251c\u2500\u2500 factory\n\u2502   \u2502   \u2502    \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2502    \u251c\u2500\u2500 data.rs\n\u2502   \u2502   \u2502    \u2514\u2500\u2500 factory.rs\n\u2502   \u2502   \u251c\u2500\u2500 pair\n\u2502   \u2502   \u2502    \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2502    \u251c\u2500\u2500 data.rs\n\u2502   \u2502   \u2502    \u2514\u2500\u2500 pair.rs\n\u2502   \u2502   \u2514\u2500\u2500 mod.rs\n\u2502   \u2514\u2500\u2500 traits\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u251c\u2500\u2500 factory.rs\n\u2502       \u251c\u2500\u2500 pair.rs\n\u2502       \u251c\u2500\u2500 math.rs\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 lib.rs\n"})}),"\n",(0,r.jsx)(t.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(t.p,{children:["OpenBrush - ",(0,r.jsx)(t.a,{href:"https://docs.openbrush.io/smart-contracts/example/setup_project",children:"Setup a project"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>s});var r=n(67294);const i={},o=r.createContext(i);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);