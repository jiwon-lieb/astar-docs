"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[8050],{40912:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(85893),s=n(11151);const r={sidebar_position:2},i="Pair Storage and Getters",o={id:"build/wasm/from-zero-to-ink-hero/dex/Pair/storage",title:"Pair Storage and Getters",description:"If you are starting the tutorial from here, Please checkout this branch and open it in your IDE.",source:"@site/docs/build/wasm/from-zero-to-ink-hero/dex/Pair/storage.md",sourceDirName:"build/wasm/from-zero-to-ink-hero/dex/Pair",slug:"/build/wasm/from-zero-to-ink-hero/dex/Pair/storage",permalink:"/ja/docs/build/wasm/from-zero-to-ink-hero/dex/Pair/storage",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/wasm/from-zero-to-ink-hero/dex/Pair/storage.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Implement PSP22 for Pair",permalink:"/ja/docs/build/wasm/from-zero-to-ink-hero/dex/Pair/psp22"},next:{title:"Mint",permalink:"/ja/docs/build/wasm/from-zero-to-ink-hero/dex/Pair/mint"}},l={},c=[{value:"1. Logics Crate",id:"1-logics-crate",level:2},{value:"2. Pair Storage",id:"2-pair-storage",level:2},{value:"3. Trait for Getters",id:"3-trait-for-getters",level:2},{value:"4. Implement Getters",id:"4-implement-getters",level:2},{value:"5. Implement Getters to Pair contract",id:"5-implement-getters-to-pair-contract",level:2}];function d(e){const t={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"pair-storage-and-getters",children:"Pair Storage and Getters"}),"\n",(0,a.jsxs)(t.p,{children:["If you are starting the tutorial from here, Please checkout this ",(0,a.jsx)(t.a,{href:"https://github.com/AstarNetwork/wasm-tutorial-dex/tree/tutorial/psp22",children:"branch"})," and open it in your IDE."]}),"\n",(0,a.jsx)(t.h2,{id:"1-logics-crate",children:"1. Logics Crate"}),"\n",(0,a.jsxs)(t.p,{children:["As described in the ",(0,a.jsx)(t.a,{href:"/ja/docs/build/wasm/from-zero-to-ink-hero/dex/Structure/file-structure",children:"File & Folder structure"})," section, the Pair business logic will be in the uniswap-v2 logics crate.\nLet's create (empty) files and folders so your project looks like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"\u251c\u2500\u2500 uniswap-v2\n\u2502   \u251c\u2500\u2500 contracts\n\u2502   \u251c\u2500\u2500 logics\n\u2502   \u2502   \u251c\u2500\u2500 impls\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 pair\n\u2502   \u2502   \u2502   \u2502    \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2502   \u2502    \u251c\u2500\u2500 data.rs\n\u2502   \u2502   \u2502   \u2502    \u2514\u2500\u2500 pair.rs\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 mod.rs\n\u2502   \u2502   \u2514\u2500\u2500 traits\n\u2502   \u2502       \u251c\u2500\u2500 mod.rs\n\u2502   \u2502       \u251c\u2500\u2500 pair.rs\n\u2502   \u251c\u2500\u2500 Cargo.toml\n\u2502   \u2514\u2500\u2500 lib.rs\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 .rustfmt\n\u2514\u2500\u2500 .gitignore\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.em,{children:"./uniswap-v2/logics/Cargo.toml"})," will be a ",(0,a.jsx)(t.code,{children:"rlib"})," crate named ",(0,a.jsx)(t.code,{children:'"uniswap_v2""'})," and import crates from ink!, scale, and Openbrush (with feature ",(0,a.jsx)(t.code,{children:'"psp22"'}),")"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-toml",children:'[package]\nname = "uniswap_v2"\nversion = "0.1.0"\nauthors = ["Stake Technologies <devops@stake.co.jp>"]\nedition = "2021"\n\n[dependencies]\nink = { version = "4.0.0", default-features = false}\n\nscale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive"] }\nscale-info = { version = "2.3", default-features = false, features = ["derive"], optional = true }\n\nopenbrush = { git = "https://github.com/727-Ventures/openbrush-contracts", version = "3.0.0", default-features = false, features = ["psp22"] }\n\n[lib]\nname = "uniswap_v2"\npath = "lib.rs"\ncrate-type = [\n    "rlib",\n]\n\n[features]\ndefault = ["std"]\nstd = [\n    "ink/std",\n    "scale/std",\n    "scale-info/std",\n    "openbrush/std",\n]\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"./uniswap-v2/logics/Cargo.toml"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"lib.rs"})," file should contain a conditional compilation attribute. It should also export ",(0,a.jsx)(t.code,{children:"impls"})," and ",(0,a.jsx)(t.code,{children:"traits"})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'#![cfg_attr(not(feature = "std"), no_std)]\n\npub mod impls;\npub mod traits;\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"./uniswap-v2/logics/lib.rs"})}),"\n",(0,a.jsx)(t.h2,{id:"2-pair-storage",children:"2. Pair Storage"}),"\n",(0,a.jsxs)(t.p,{children:["The Uniswap V2 Pair contract has ",(0,a.jsx)(t.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L18",children:"storage fields"})," in Solidity that we should implement as shown below:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"address public factory;\naddress public token0;\naddress public token1;\n\nuint112 private reserve0;           // uses single storage slot, accessible via getReserves\nuint112 private reserve1;           // uses single storage slot, accessible via getReserves\nuint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\nuint public price0CumulativeLast;\nuint public price1CumulativeLast;\nuint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n"})}),"\n",(0,a.jsx)(t.p,{children:"ink! uses most Substrate primitive types. Here is a conversion table between Solidity and ink! types:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Solidity"}),(0,a.jsx)(t.th,{children:"ink!"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"uint256"}),(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"https://docs.rs/primitive-types/latest/primitive_types/struct.U256.html",children:"U256"})})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"any other uint"}),(0,a.jsx)(t.td,{children:"u128 (or lower)"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"address"}),(0,a.jsx)(t.td,{children:"AccountId"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"mapping(key => value)"}),(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"https://docs.rs/ink_storage/latest/ink_storage/struct.Mapping.html",children:"Mapping(key, value)"})})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"mapping(key1 => mapping(key2 => value))"}),(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"https://substrate.stackexchange.com/a/3993/567",children:"Mapping((key1 ,key2), value)"})})]})]})]}),"\n",(0,a.jsxs)(t.p,{children:["Let's create a storage struct in ",(0,a.jsx)(t.em,{children:"./logics/impls/pair/data.rs"}),". Name the struct ",(0,a.jsx)(t.code,{children:"Data"})," and add all the required fields."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub struct Data {\n    pub factory: AccountId,\n    pub token_0: AccountId,\n    pub token_1: AccountId,\n    pub reserve_0: Balance,\n    pub reserve_1: Balance,\n    pub block_timestamp_last: Timestamp,\n    pub price_0_cumulative_last: Balance,\n    pub price_1_cumulative_last: Balance,\n    pub k_last: u128,\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Openbrush uses a specified storage key instead of the default one in the attribute ",(0,a.jsx)(t.a,{href:"https://github.com/Supercolony-net/openbrush-contracts/blob/main/lang/macro/src/lib.rs#L447",children:"openbrush::upgradeable_storage"}),". It implements all ",(0,a.jsx)(t.a,{href:"https://docs.openbrush.io/smart-contracts/upgradeable#suggestions-on-how-follow-the-rules",children:"required traits"})," with the specified storage key (storage key is a required input argument of the macro).\nTo generate a unique key Openbrush provides the ",(0,a.jsx)(t.a,{href:"https://docs.openbrush.io/smart-contracts/upgradeable#unique-storage-key",children:"openbrush::storage_unique_key!"})," declarative macro that is based on the name of the struct and its file path. Let's add this to our struct and import the required fields."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"use openbrush::traits::{\n    AccountId,\n    Balance,\n    Timestamp,\n};\n\npub const STORAGE_KEY: u32 = openbrush::storage_unique_key!(Data);\n\n#[derive(Debug)]\n#[openbrush::upgradeable_storage(STORAGE_KEY)]\npub struct Data {\n    pub factory: AccountId,\n    pub token_0: AccountId,\n    pub token_1: AccountId,\n    pub reserve_0: Balance,\n    pub reserve_1: Balance,\n    pub block_timestamp_last: Timestamp,\n    pub price_0_cumulative_last: Balance,\n    pub price_1_cumulative_last: Balance,\n    pub k_last: u128,\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"./logics/impls/pair/data.rs"})}),"\n",(0,a.jsxs)(t.p,{children:["And impl ",(0,a.jsx)(t.code,{children:"Default"})," for the ",(0,a.jsx)(t.code,{children:"Data"})," struct:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"...\nimpl Default for Data {\n    fn default() -> Self {\n        Self {\n            factory: ZERO_ADDRESS.into(),\n            token_0: ZERO_ADDRESS.into(),\n            token_1: ZERO_ADDRESS.into(),\n            reserve_0: 0,\n            reserve_1: 0,\n            block_timestamp_last: 0,\n            price_0_cumulative_last: Default::default(),\n            price_1_cumulative_last: Default::default(),\n            k_last: Default::default(),\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"3-trait-for-getters",children:"3. Trait for Getters"}),"\n",(0,a.jsxs)(t.p,{children:["Unlike Solidity that will automatically create getters for the storage items, you need to add them yourself in ink!. For this we will create a trait and add generic implementation.\nin the ",(0,a.jsx)(t.em,{children:"./logics/traits/pair.rs"})," file, let's create a trait with the getters functions and make them callable with ",(0,a.jsx)(t.code,{children:"#[ink(message)]"})," :"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub trait Pair {\n    #[ink(message)]\n    fn get_reserves(&self) -> (Balance, Balance, Timestamp);\n\n    #[ink(message)]\n    fn initialize(&mut self, token_0: AccountId, token_1: AccountId) -> Result<(), PairError>;\n\n    #[ink(message)]\n    fn get_token_0(&self) -> AccountId;\n\n    #[ink(message)]\n    fn get_token_1(&self) -> AccountId;\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Openbrush provides ",(0,a.jsx)(t.code,{children:"#[openbrush::trait_definition]"})," that will make sure your trait (and its default implementation) will be generated in the contract. Also, you can create a wrapper around this trait so it can be used for cross-contract calls (so no need to import the contract as ink-as-dependancy). Import what is needed from Openbrush:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"use openbrush::traits::{\n    AccountId,\n    Balance,\n    Timestamp,\n};\n\n#[openbrush::wrapper]\npub type PairRef = dyn Pair;\n\n#[openbrush::trait_definition]\npub trait Pair {\n    #[ink(message)]\n    fn get_reserves(&self) -> (Balance, Balance, Timestamp);\n\n    #[ink(message)]\n    fn initialize(&mut self, token_0: AccountId, token_1: AccountId) -> Result<(), PairError>;\n\n    #[ink(message)]\n    fn get_token_0(&self) -> AccountId;\n\n    #[ink(message)]\n    fn get_token_1(&self) -> AccountId;\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"./logics/traits/pair.rs"})}),"\n",(0,a.jsxs)(t.p,{children:["The last thing to add will be the Error enum, and each contract should use its own. As it will be used in function arguments it should implement Scale encode & decode.\nFor the moment we don't need a proper error so just add ",(0,a.jsx)(t.code,{children:"Error"})," as field:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:'...\n#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]\npub enum PairError {\n    Error,\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"./logics/traits/pair.rs"})}),"\n",(0,a.jsx)(t.h2,{id:"4-implement-getters",children:"4. Implement Getters"}),"\n",(0,a.jsxs)(t.p,{children:["in ",(0,a.jsx)(t.em,{children:"./logics/impls/pair/pair.rs"})," add an impl block for generic type ",(0,a.jsx)(t.code,{children:"data::Data"}),". We wrap the Data struct in Storage trait to add it as trait bound."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"impl<T: Storage<data::Data>> Pair for T {}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"get_reserves"})}),"\n",(0,a.jsxs)(t.p,{children:["This function should return a tuple of reserves & timestamp of type ",(0,a.jsx)(t.code,{children:"(Balance, Balance, Timestamp)"}),". It takes ",(0,a.jsx)(t.code,{children:"&self"})," as it should access to Data storage struct but will not modify it hence no need for a mutable ref."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"fn get_reserves(&self) -> (Balance, Balance, Timestamp) {\n    (\n        self.data::<data::Data>().reserve_0,\n        self.data::<data::Data>().reserve_1,\n        self.data::<data::Data>().block_timestamp_last,\n    )\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"initialize"})}),"\n",(0,a.jsxs)(t.p,{children:["This method is more of a setter as it will set token address in storage. That's why it takes a ",(0,a.jsx)(t.code,{children:"&mut self"})," as the first argument.",(0,a.jsx)(t.br,{}),"\n","As a general rule if a function only takes ",(0,a.jsx)(t.code,{children:"&self"})," then it will not modify the state so it will only be called as a query.\nIf the functions takes an ",(0,a.jsx)(t.code,{children:"&mut self"})," it will make state change so can be called as a transaction, and should return a Result<T, E>.\nOnly factory can call this ",(0,a.jsx)(t.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Pair.sol#L67",children:"function"}),", but we will add ",(0,a.jsx)(t.code,{children:"only_owner"})," modifier later in this tutorial."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"fn initialize(\n    &mut self,\n    token_0: AccountId,\n    token_1: AccountId,\n) -> Result<(), PairError> {\n    self.data::<data::Data>().token_0 = token_0;\n    self.data::<data::Data>().token_1 = token_1;\n    Ok(())\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"get_token"})}),"\n",(0,a.jsx)(t.p,{children:"These two functions return the accountId of the tokens"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"fn get_token_0(&self) -> AccountId {\n    self.data::<data::Data>().token_0\n}\n\nfn get_token_1(&self) -> AccountId {\n    self.data::<data::Data>().token_1\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"Add imports, and your file should look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"pub use crate::{\n    impls::pair::*,\n    traits::pair::*,\n};\nuse openbrush::traits::{\n    AccountId,\n    Balance,\n    Storage,\n    Timestamp,\n};\n\nimpl<T: Storage<data::Data>> Pair for T {\n    fn get_reserves(&self) -> (Balance, Balance, Timestamp) {\n        (\n            self.data::<data::Data>().reserve_0,\n            self.data::<data::Data>().reserve_1,\n            self.data::<data::Data>().block_timestamp_last,\n        )\n    }\n\n    fn initialize(\n        &mut self,\n        token_0: AccountId,\n        token_1: AccountId,\n    ) -> Result<(), PairError> {\n        self.data::<data::Data>().token_0 = token_0;    \n        self.data::<data::Data>().token_1 = token_1;\n        Ok(())\n    }\n\n    fn get_token_0(&self) -> AccountId {\n        self.data::<data::Data>().token_0\n    }\n\n    fn get_token_1(&self) -> AccountId {\n        self.data::<data::Data>().token_1\n    }\n}\n"})}),"\n",(0,a.jsx)(t.h2,{id:"5-implement-getters-to-pair-contract",children:"5. Implement Getters to Pair contract"}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.em,{children:"./contracts/pair/Cargo.toml"})," import the uniswap-v2 logics crate and add it to the std features"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-toml",children:'...\nuniswap_v2 = { path = "../../logics", default-features = false }\n...\nstd = [\n"ink/std",\n"scale/std",\n"scale-info/std",\n"openbrush/std",\n"uniswap_v2/std"\n]\n'})}),"\n",(0,a.jsxs)(t.p,{children:["In the contract ",(0,a.jsx)(t.em,{children:"lib.rs"})," import everything from pair traits (and impls):"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"use uniswap_v2::{\n    impls::pair::*,\n    traits::pair::*,\n};\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Add the ",(0,a.jsx)(t.code,{children:"Data"})," storage struct to the contract storage struct:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"#[ink(storage)]\n#[derive(Default, Storage)]\npub struct PairContract {\n    #[storage_field]\n    psp22: psp22::Data,\n    #[storage_field]\n    pair: data::Data,\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"And just below the storage struct impl Pair trait for the PairContract:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-rust",children:"    impl Pair for PairContract {}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["And that's it!",(0,a.jsx)(t.br,{}),"\n","In this section we've gone over how to create a trait and its generic implementation, and added them to the Pair contract. Check your Pair contract with (run from the contract folder):"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-console",children:"cargo contract build\n"})}),"\n",(0,a.jsxs)(t.p,{children:["It should now look like this ",(0,a.jsx)(t.a,{href:"https://github.com/AstarNetwork/wasm-tutorial-dex/tree/tutorial/storage-end",children:"branch"}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>i});var a=n(67294);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);