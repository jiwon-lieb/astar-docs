"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[4027],{94571:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>o});var t=r(85893),i=r(11151);const s={sidebar_position:3,title:"dApp Staking Parameters"},d=void 0,a={id:"learn/dapp-staking/protocol-parameters",title:"dApp Staking Parameters",description:"Overview",source:"@site/docs/learn/dapp-staking/protocol-parameters.md",sourceDirName:"learn/dapp-staking",slug:"/learn/dapp-staking/protocol-parameters",permalink:"/ja/docs/learn/dapp-staking/protocol-parameters",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/learn/dapp-staking/protocol-parameters.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"dApp Staking Parameters"},sidebar:"tutorialSidebar",previous:{title:"dApp Staking FAQ",permalink:"/ja/docs/learn/dapp-staking/dapp-staking-faq"},next:{title:"Glossary",permalink:"/ja/docs/learn/glossary"}},l={},o=[{value:"Overview",id:"overview",level:2},{value:"Era Reward Span Length",id:"era-reward-span-length",level:3},{value:"Reward Retention In Periods",id:"reward-retention-in-periods",level:3},{value:"Max Number Of Contracts",id:"max-number-of-contracts",level:3},{value:"Max Unlocking Chunks",id:"max-unlocking-chunks",level:3},{value:"Minimum Locked Amount",id:"minimum-locked-amount",level:3},{value:"Unlocking Period",id:"unlocking-period",level:3},{value:"Max Number Of Staked Contracts",id:"max-number-of-staked-contracts",level:3},{value:"Minimum Stake Amount",id:"minimum-stake-amount",level:3},{value:"Number Of Tiers",id:"number-of-tiers",level:3},{value:"Reward Distribution",id:"reward-distribution",level:3},{value:"Slot Distribution",id:"slot-distribution",level:3},{value:"Tier Thresholds",id:"tier-thresholds",level:3},{value:"Price Aggregation Duration",id:"price-aggregation-duration",level:3},{value:"Circular Buffer Length",id:"circular-buffer-length",level:2},{value:"Network Values",id:"network-values",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:["The following parameters are tightly tied to dApp staking, however, some parameters are shared with the ",(0,t.jsx)(n.em,{children:"Tokenomics 2.0"})," model.\nTo find out more, please check the documentation ",(0,t.jsx)(n.a,{href:"/docs/learn/tokenomics2/Inflation/",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"era-reward-span-length",children:"Era Reward Span Length"}),"\n",(0,t.jsxs)(n.p,{children:["How many eras of reward information do we store in a single database entry.\nThis puts an upper limit on how many rewards can a single ",(0,t.jsx)(n.code,{children:"claim_staker_reward"})," call claim.\nIncreasing this number has an impact on the PoV size consumed by the claim calls so it has to be kept relatively small."]}),"\n",(0,t.jsx)(n.h3,{id:"reward-retention-in-periods",children:"Reward Retention In Periods"}),"\n",(0,t.jsx)(n.p,{children:"For how many periods do we keep staker & dApp rewards before they expire, and become unavailable for claiming.\nThe larger this parameter is, the higher the deviation from the max inflation rate can occur since if many users have very old unclaimed rewards, and decide to claim them at a similar point in time, this would cause inflation to be spike up."}),"\n",(0,t.jsx)(n.h3,{id:"max-number-of-contracts",children:"Max Number Of Contracts"}),"\n",(0,t.jsxs)(n.p,{children:["There is a technical limitation on how many dApps the protocol can support at this time.\nHowever, this limit won't have a ",(0,t.jsx)(n.em,{children:"real"})," impact on the protocol since at the moment of writing this document, neither Astar or Shiden are close to that limit."]}),"\n",(0,t.jsx)(n.h3,{id:"max-unlocking-chunks",children:"Max Unlocking Chunks"}),"\n",(0,t.jsxs)(n.p,{children:["Maximum number of unlocking chunks that a staker can simultaneously have.\nThe ",(0,t.jsx)(n.em,{children:"chunk"})," consists of some ",(0,t.jsx)(n.em,{children:"amount"})," together with ",(0,t.jsx)(n.em,{children:"block number"})," after which the chunk becomes unlocked."]}),"\n",(0,t.jsx)(n.h3,{id:"minimum-locked-amount",children:"Minimum Locked Amount"}),"\n",(0,t.jsxs)(n.p,{children:["The minimum amount user has to ",(0,t.jsx)(n.em,{children:"lock"})," in order to participate in dApp staking protocol.\nFrom the technical standpoint, the ",(0,t.jsx)(n.em,{children:"locked"})," amount should cover the storage rent fee requirements, and prevents spamming of accounts with low ",(0,t.jsx)(n.em,{children:"lock"})," amount.\nFrom the user\u2019s standpoint, having low ",(0,t.jsx)(n.em,{children:"locked"})," amount doesn\u2019t make much sense because their rewards might not even be high enough to cover the transaction fee expense to claim those rewards."]}),"\n",(0,t.jsx)(n.h3,{id:"unlocking-period",children:"Unlocking Period"}),"\n",(0,t.jsxs)(n.p,{children:["Number of blocks required for ",(0,t.jsx)(n.em,{children:"unlocking chunk"})," to become ",(0,t.jsx)(n.em,{children:"unlocked"})," after starting the unlocking process."]}),"\n",(0,t.jsx)(n.h3,{id:"max-number-of-staked-contracts",children:"Max Number Of Staked Contracts"}),"\n",(0,t.jsx)(n.p,{children:"Max number of staked contract entries a single account is allowed to have at once.\nThis is again a technical bound, to provide additional security to the pallet."}),"\n",(0,t.jsx)(n.h3,{id:"minimum-stake-amount",children:"Minimum Stake Amount"}),"\n",(0,t.jsxs)(n.p,{children:["Similar to the ",(0,t.jsx)(n.em,{children:"minimum lock amount"}),", but refers to the ",(0,t.jsx)(n.em,{children:"stake"})," amount.\nIt's suggested to keep this value same as the ",(0,t.jsx)(n.em,{children:"minimum locked amount"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"number-of-tiers",children:"Number Of Tiers"}),"\n",(0,t.jsx)(n.p,{children:"Number of distinct tiers in the protocol."}),"\n",(0,t.jsx)(n.h3,{id:"reward-distribution",children:"Reward Distribution"}),"\n",(0,t.jsxs)(n.p,{children:["Describes the portion/percentage of the dApp reward pool that goes towards each tier.\nE.g. ",(0,t.jsx)(n.code,{children:"[10%, 20%, 30%, 40%]"})," means that ",(0,t.jsx)(n.code,{children:"10%"})," of the reward pool goes for ",(0,t.jsx)(n.strong,{children:"tier 1"})," rewards, ",(0,t.jsx)(n.code,{children:"20%"})," for ",(0,t.jsx)(n.strong,{children:"tier 2"})," rewards, and so on."]}),"\n",(0,t.jsx)(n.h3,{id:"slot-distribution",children:"Slot Distribution"}),"\n",(0,t.jsxs)(n.p,{children:["Describes the portion/percentage of the total number of slots that goes towards each tier.\nE.g. ",(0,t.jsx)(n.code,{children:"[5%, 15%, 20%, 60%]"})," means that ",(0,t.jsx)(n.code,{children:"5%"})," of the total slots are assigned for ",(0,t.jsx)(n.strong,{children:"tier 1"})," dApps, ",(0,t.jsx)(n.code,{children:"15%"})," for ",(0,t.jsx)(n.strong,{children:"tier 2"})," dApps, and so on."]}),"\n",(0,t.jsx)(n.h3,{id:"tier-thresholds",children:"Tier Thresholds"}),"\n",(0,t.jsx)(n.p,{children:"The threshold that dApp has to satisfy, essentially the total staked amount, in order to be eligible to enter a tier.\nThere are two types of thresholds:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Fixed"})," - threshold has a fixed value and doesn't change"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Dynamic"})," - threshold has an initial value, which changes dynamically as the number of slots change, but also has a minimum allowed value."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"price-aggregation-duration",children:"Price Aggregation Duration"}),"\n",(0,t.jsxs)(n.p,{children:["Time period, expressed in blocks, during which native currency price is aggregated. When expired, average value is calculated and stored into the ",(0,t.jsx)(n.em,{children:"moving-average"})," circular buffer."]}),"\n",(0,t.jsx)(n.h2,{id:"circular-buffer-length",children:"Circular Buffer Length"}),"\n",(0,t.jsxs)(n.p,{children:["Length of the circular buffer used to implement the ",(0,t.jsx)(n.em,{children:"moving-average"})," solution."]}),"\n",(0,t.jsx)(n.h2,{id:"network-values",children:"Network Values"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter name"}),(0,t.jsx)(n.th,{children:"Astar"}),(0,t.jsx)(n.th,{children:"Shiden"}),(0,t.jsx)(n.th,{children:"Shibuya"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Era Reward Span Length"}),(0,t.jsx)(n.td,{children:"16"}),(0,t.jsx)(n.td,{children:"16"}),(0,t.jsx)(n.td,{children:"16"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Reward Retention In Periods"}),(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"3"}),(0,t.jsx)(n.td,{children:"2"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Max Number Of Contracts"}),(0,t.jsx)(n.td,{children:"500"}),(0,t.jsx)(n.td,{children:"500"}),(0,t.jsx)(n.td,{children:"500"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Max Unlocking Chunks"}),(0,t.jsx)(n.td,{children:"8"}),(0,t.jsx)(n.td,{children:"8"}),(0,t.jsx)(n.td,{children:"8"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Minimum Locked Amount"}),(0,t.jsx)(n.td,{children:"500 ASTR"}),(0,t.jsx)(n.td,{children:"50 SDN"}),(0,t.jsx)(n.td,{children:"5 SBY"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Unlocking Period"}),(0,t.jsx)(n.td,{children:"9"}),(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"4"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Max Number Of Staked Contracts"}),(0,t.jsx)(n.td,{children:"16"}),(0,t.jsx)(n.td,{children:"16"}),(0,t.jsx)(n.td,{children:"8"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Minimum Stake Amount"}),(0,t.jsx)(n.td,{children:"500 ASTR"}),(0,t.jsx)(n.td,{children:"50 SDN"}),(0,t.jsx)(n.td,{children:"5 SBY"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Number Of Tiers"}),(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"4"}),(0,t.jsx)(n.td,{children:"4"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Reward Distribution"}),(0,t.jsx)(n.td,{children:"[25%, 47%, 25%, 3%]"}),(0,t.jsx)(n.td,{children:"[25%, 47%, 25%, 3%]"}),(0,t.jsx)(n.td,{children:"[40%, 30%, 20%, 10%]"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Slot Portions"}),(0,t.jsx)(n.td,{children:"[5%, 20%, 30%, 45%]"}),(0,t.jsx)(n.td,{children:"[5%, 20%, 30%, 45%]"}),(0,t.jsx)(n.td,{children:"[10%, 20%, 30%, 40%]"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Tier 1 Threshold"}),(0,t.jsx)(n.td,{children:"Dynamic(300M/200M ASTR)"}),(0,t.jsx)(n.td,{children:"Dynamic(3M/2M SDN)"}),(0,t.jsx)(n.td,{children:"Dynamic(3000/2500 SBY)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Tier 2 Threshold"}),(0,t.jsx)(n.td,{children:"Dynamic(75M/50M ASTR)"}),(0,t.jsx)(n.td,{children:"Dynamic(750k/500k SDN)"}),(0,t.jsx)(n.td,{children:"Dynamic(2000/1500 SBY)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Tier 3 Threshold"}),(0,t.jsx)(n.td,{children:"Dynamic(20M/15M ASTR)"}),(0,t.jsx)(n.td,{children:"Dynamic(200k/150k SDN)"}),(0,t.jsx)(n.td,{children:"Dynamic(800/500 SBY)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Tier 4 Threshold"}),(0,t.jsx)(n.td,{children:"Fixed(1.5M ASTR)"}),(0,t.jsx)(n.td,{children:"Fixed(50k SDN)"}),(0,t.jsx)(n.td,{children:"Fixed(200 SBY)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Price Aggregation Duration"}),(0,t.jsx)(n.td,{children:"7200 blocks"}),(0,t.jsx)(n.td,{children:"7200 blocks"}),(0,t.jsx)(n.td,{children:"7200 blocks"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Circular Buffer Length"}),(0,t.jsx)(n.td,{children:"7"}),(0,t.jsx)(n.td,{children:"7"}),(0,t.jsx)(n.td,{children:"7"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>d});var t=r(67294);const i={},s=t.createContext(i);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);