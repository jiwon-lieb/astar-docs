"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[7293],{31437:(t,o,e)=>{e.r(o),e.d(o,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var n=e(85893),i=e(11151);const s={sidebar_position:3},a="Other",r={id:"build/wasm/tooling/tools",title:"Other",description:"Sol2Ink",source:"@site/docs/build/wasm/tooling/tools.md",sourceDirName:"build/wasm/tooling",slug:"/build/wasm/tooling/tools",permalink:"/ja/docs/build/wasm/tooling/tools",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/wasm/tooling/tools.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Polkadot.js Apps UI",permalink:"/ja/docs/build/wasm/tooling/polkadotjs"},next:{title:"aWASoMe",permalink:"/ja/docs/build/wasm/tooling/awasome"}},l={},c=[{value:"Sol2Ink",id:"sol2ink",level:2},{value:"Typechain-Polkadot",id:"typechain-polkadot",level:2},{value:"Solang",id:"solang",level:2},{value:"parity-common",id:"parity-common",level:2}];function d(t){const o={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",...(0,i.a)(),...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.h1,{id:"other",children:"Other"}),"\n",(0,n.jsx)(o.h2,{id:"sol2ink",children:"Sol2Ink"}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.a,{href:"https://github.com/727-Ventures/sol2ink",children:"Sol2ink"})," is another tool maintained by the ",(0,n.jsx)(o.a,{href:"https://www.brushfam.io/",children:"BrushFam"})," team, used for easy migration of smart contracts from Solidity to ink! and Rust, that helps developers migrate smart contracts from EVM platforms, to Polkadot."]}),"\n",(0,n.jsx)(o.p,{children:"How does it work? Simply input your Solidity code, and in a few seconds Sol2Ink will convert it to an ink! smart contract. Since the contracts are transcoded automatically, it is then a good idea to check them over (and build them) to see if they still perform as expected. Even still, most of the heavy lifting will be done for you, using the Sol2Ink tool."}),"\n",(0,n.jsx)(o.h2,{id:"typechain-polkadot",children:"Typechain-Polkadot"}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.a,{href:"https://github.com/727-Ventures/typechain-polkadot",children:"Typechain-Polkadot"})," is another ",(0,n.jsx)(o.a,{href:"https://www.brushfam.io/",children:"BrushFam"}),"-maintained tool, designed to improve developers\u2019 experience with frontend usage of ink! smart contracts, and deployment and integration testing by providing TypeScript types for ink! smart contracts."]}),"\n",(0,n.jsx)(o.p,{children:"This tool will build contracts, create the artifcats, and then create the TypeScript classes which can then be integrated into your UI or TypeScript tests."}),"\n",(0,n.jsx)(o.h2,{id:"solang",children:"Solang"}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.a,{href:"https://solang.readthedocs.io/en/latest/",children:"Solang"})," is a Solidity Compiler for Solana and Substrate. Using Solang, you can compile smart contracts written in Solidity for Solana and ",(0,n.jsx)(o.a,{href:"https://substrate.io/",children:"Parity Substrate"}),". Solang uses the ",(0,n.jsx)(o.a,{href:"https://www.llvm.org/",children:"llvm"})," compiler framework to produce WebAssembly (Wasm) or BPF contract code. As result, the output is highly optimized, which saves you in gas costs or compute units."]}),"\n",(0,n.jsx)(o.h2,{id:"parity-common",children:"parity-common"}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.a,{href:"https://github.com/paritytech/parity-common",children:(0,n.jsx)(o.code,{children:"parity-common"})})," is a collection of crates that you can use in your ink! contracts."]}),"\n",(0,n.jsx)(o.p,{children:"It offers all Ethereum types and is useful if you would like to port Solidity code to ink!."})]})}function h(t={}){const{wrapper:o}={...(0,i.a)(),...t.components};return o?(0,n.jsx)(o,{...t,children:(0,n.jsx)(d,{...t})}):d(t)}},11151:(t,o,e)=>{e.d(o,{Z:()=>r,a:()=>a});var n=e(67294);const i={},s=n.createContext(i);function a(t){const o=n.useContext(s);return n.useMemo((function(){return"function"==typeof t?t(o):{...o,...t}}),[o,t])}function r(t){let o;return o=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:a(t.components),n.createElement(s.Provider,{value:o},t.children)}}}]);