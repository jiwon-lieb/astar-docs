"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[9945],{5104:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var a=n(85893),r=n(11151);const o={sidebar_position:3,title:"zkEVM Protocol FAQs",sidebar_label:"Protocol FAQs"},s=void 0,i={id:"build/zkEVM/faq/zkevm-protocol-faq",title:"zkEVM Protocol FAQs",description:"This document compiles some of the frequently asked questions related to the Astar zkEVM protocol. For more details, check out Polygon zkEVM documentation.",source:"@site/docs/build/zkEVM/faq/zkevm-protocol-faq.md",sourceDirName:"build/zkEVM/faq",slug:"/build/zkEVM/faq/zkevm-protocol-faq",permalink:"/es/docs/build/zkEVM/faq/zkevm-protocol-faq",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/zkEVM/faq/zkevm-protocol-faq.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"zkEVM Protocol FAQs",sidebar_label:"Protocol FAQs"},sidebar:"tutorialSidebar",previous:{title:"EVM Equivalence",permalink:"/es/docs/build/zkEVM/faq/zkevm-eth-faq"},next:{title:"Builder Guides",permalink:"/es/docs/build/builder-guides/"}},c={},d=[{value:"How are transactions collected and ordered?",id:"how-are-transactions-collected-and-ordered",level:3},{value:"Are there any time or transaction intervals for a sequencer to wait before moving forward to make a Rollup batch?",id:"are-there-any-time-or-transaction-intervals-for-a-sequencer-to-wait-before-moving-forward-to-make-a-rollup-batch",level:3},{value:"What are the stages that a transaction goes through in order to be finalized on Layer 1?",id:"what-are-the-stages-that-a-transaction-goes-through-in-order-to-be-finalized-on-layer-1",level:3},{value:"How does a Sequencer validate a specific transaction in order to generate proof?",id:"how-does-a-sequencer-validate-a-specific-transaction-in-order-to-generate-proof",level:3},{value:"When do transactions achieve finality in Astar zkEVM?",id:"when-do-transactions-achieve-finality-in-astar-zkevm",level:3},{value:"Are Sequencers and Provers in-house or external? How do you ensure that your Sequencers and Provers maintain decentralization?",id:"are-sequencers-and-provers-in-house-or-external-how-do-you-ensure-that-your-sequencers-and-provers-maintain-decentralization",level:3},{value:"Can a zkNode serve as both Sequencer and Aggregator? If not, how is it determined what role a node can play?",id:"can-a-zknode-serve-as-both-sequencer-and-aggregator-if-not-how-is-it-determined-what-role-a-node-can-play",level:3},{value:"How exactly do the state sync components do the syncing in Layer 2 after a transaction batch and its validity proof is mined on Layer 1?",id:"how-exactly-do-the-state-sync-components-do-the-syncing-in-layer-2-after-a-transaction-batch-and-its-validity-proof-is-mined-on-layer-1",level:3},{value:"What is Forced Batches?",id:"what-is-forced-batches",level:3},{value:"What is an Emergency State, and when is it triggered?",id:"what-is-an-emergency-state-and-when-is-it-triggered",level:3}];function h(e){const t={a:"a",code:"code",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["This document compiles some of the frequently asked questions related to the Astar zkEVM protocol. For more details, check out ",(0,a.jsx)(t.a,{href:"https://wiki.polygon.technology/docs/category/zkevm-protocol/",children:"Polygon zkEVM documentation"}),"."]}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)(t.h3,{id:"how-are-transactions-collected-and-ordered",children:"How are transactions collected and ordered?"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Transactions on the Astar zkEVM network are ",(0,a.jsx)(t.strong,{children:"created in users' wallets and signed with their private keys"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["Once generated and signed, the ",(0,a.jsx)(t.strong,{children:"transactions are sent to the Trusted Sequencer's node"})," via their JSON-RPC interface."]}),"\n",(0,a.jsxs)(t.li,{children:["The transactions are then ",(0,a.jsx)(t.strong,{children:"stored in the pending transactions pool, where they await the Sequencer's selection"}),"."]}),"\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.strong,{children:"Trusted Sequencer reads transactions"})," from the pool and decides whether to discard them or order and execute them."]}),"\n",(0,a.jsxs)(t.li,{children:["Lastly, the ",(0,a.jsx)(t.strong,{children:"Sequencer organizes the transactions into batches"}),", followed by the sequencing of the batches."]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"are-there-any-time-or-transaction-intervals-for-a-sequencer-to-wait-before-moving-forward-to-make-a-rollup-batch",children:"Are there any time or transaction intervals for a sequencer to wait before moving forward to make a Rollup batch?"}),"\n",(0,a.jsx)(t.p,{children:"The sequencer always has an open batch. Transactions are added to this batch until this batch is full or a big timeout happens. Those batches are also accumulated until it reaches 128K of batches (or a big timeout) and then a sequencing transaction to Layer 1 is sent."}),"\n",(0,a.jsxs)(t.p,{children:["From the Layer 2 user perspective, a new Layer 2 block (different from the Layer 2 batch) is closed and sent to the user. The user perceives the transaction finality even if the Layer 2 batch is not closed. ",(0,a.jsx)(t.strong,{children:"One Layer 2 Transaction is one Layer 2 Block"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"what-are-the-stages-that-a-transaction-goes-through-in-order-to-be-finalized-on-layer-1",children:"What are the stages that a transaction goes through in order to be finalized on Layer 1?"}),"\n",(0,a.jsx)(t.p,{children:"The process of validating a specific transaction within the batch typically involves three steps:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Trusted State:"})," This state is given by the trusted sequencer almost instantaneously. No Layer 1 transactions are required."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Virtual State:"})," Transactions are on Layer 1. These transactions and their order cannot be modified as the state is final and anybody could calculate."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Verified State:"})," When the virtual state is verified by the smart contract, the funds can be withdrawn."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"how-does-a-sequencer-validate-a-specific-transaction-in-order-to-generate-proof",children:"How does a Sequencer validate a specific transaction in order to generate proof?"}),"\n",(0,a.jsx)(t.p,{children:"The Sequencer retrieves the transaction from the transaction pool and verifies that it is properly formatted and contains all the necessary information. The Sequencer does the following checks:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Checks that the transaction is valid by checking that the Sender has enough funds to cover the gas costs of the transaction and that the smart contract called, if any, is valid and has the correct bytecode."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Checks that the transaction is not a duplicate by checking the transaction nonce of the Sender to ensure that it is one greater than the last nonce used."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Checks that the transaction is not a double-spend by checking that the Sender's account balance has not been already spent in another transaction."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Once the transaction is deemed valid, the Sequencer applies the transaction to the current state of the Astar zkEVM, updating the state of the smart contract and the account balances as necessary. Duration and cost vary depending on traffic and prevailing gas prices."}),"\n",(0,a.jsx)(t.h3,{id:"when-do-transactions-achieve-finality-in-astar-zkevm",children:"When do transactions achieve finality in Astar zkEVM?"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"If the user trusts the Sequencer"}),", transactions are considered final once the Sequencer sequences it (or Trusted State)."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"If the user trusts only the Layer 1 state"}),", then the transaction will be final at the moment it reaches ",(0,a.jsx)(t.strong,{children:"Virtual State"}),". This means, once the data is available and the transaction is already on Layer 1."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"In case the user needs to withdraw funds"}),", he/she needs to wait for the Prover to convert the implicit state to an explicit state. We call this last state the ",(0,a.jsx)(t.strong,{children:"Consolidated or Verified State"}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"are-sequencers-and-provers-in-house-or-external-how-do-you-ensure-that-your-sequencers-and-provers-maintain-decentralization",children:"Are Sequencers and Provers in-house or external? How do you ensure that your Sequencers and Provers maintain decentralization?"}),"\n",(0,a.jsxs)(t.p,{children:["Astar zkEVM's ",(0,a.jsx)(t.strong,{children:"Sequencer will be centralized during early stages"}),". We have a roadmap to decentralize the sequencer in future releases."]}),"\n",(0,a.jsxs)(t.p,{children:["Likewise, the ",(0,a.jsx)(t.strong,{children:"Prover is also centralized at the beginning"})," but the vision is to enable a Provers market. Provers cannot do much but generate proofs. To have a decentralized system of Provers is much more critical (and difficult) than the Sequencer."]}),"\n",(0,a.jsx)(t.h3,{id:"can-a-zknode-serve-as-both-sequencer-and-aggregator-if-not-how-is-it-determined-what-role-a-node-can-play",children:"Can a zkNode serve as both Sequencer and Aggregator? If not, how is it determined what role a node can play?"}),"\n",(0,a.jsx)(t.p,{children:"A zkNode can potentially serve as both a sequencer and an aggregator, depending on the specific implementation of the zero-knowledge proof protocol."}),"\n",(0,a.jsx)(t.p,{children:"In some implementations, a node may only be able to perform one function or the other. The role a node can play is determined by the specific implementation of the protocol and the requirements of the network. For example, some protocols may require a certain number of nodes to perform the role of sequencer and a certain number to perform the role of aggregator in order to ensure the security and efficiency of the network."}),"\n",(0,a.jsx)(t.h3,{id:"how-exactly-do-the-state-sync-components-do-the-syncing-in-layer-2-after-a-transaction-batch-and-its-validity-proof-is-mined-on-layer-1",children:"How exactly do the state sync components do the syncing in Layer 2 after a transaction batch and its validity proof is mined on Layer 1?"}),"\n",(0,a.jsxs)(t.p,{children:["An easy way to summarize is that for each batch, one hash named ",(0,a.jsx)(t.code,{children:"globalExitRoot"})," is transferred from ",(0,a.jsx)(t.strong,{children:"Layer 1 \u2192 Layer 2"})," and another hash is transferred from ",(0,a.jsx)(t.strong,{children:"Layer 2 \u2192 Layer 1"})," named ",(0,a.jsx)(t.code,{children:"localExitRoot"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"globalExitRoot"})," mainly includes all the deposits and ",(0,a.jsx)(t.code,{children:"localExitRoot"})," includes all the withdrawals."]}),"\n",(0,a.jsx)(t.h3,{id:"what-is-forced-batches",children:"What is Forced Batches?"}),"\n",(0,a.jsx)(t.p,{children:"A Forced Batch is an Layer 2 batch included in an Layer 1 transaction. Trusted Sequencer is forced to include those batches. This is how a user guarantees that they can withdraw funds even if they are censored by Trusted Sequencer."}),"\n",(0,a.jsx)(t.p,{children:"This property is what memes the system censorship resistance."}),"\n",(0,a.jsx)(t.h3,{id:"what-is-an-emergency-state-and-when-is-it-triggered",children:"What is an Emergency State, and when is it triggered?"}),"\n",(0,a.jsx)(t.p,{children:"Emergency State halts the functionalities such as the sequencing of batches, verifying of batches, and forced batches."}),"\n",(0,a.jsx)(t.p,{children:"It can be triggered by the owner of a smart contract or, in the case of Astar zkEVM, by a Security Council multisig. This means that the Security Council can invoke the Emergency State if the pending state timeout is reached or a threatening vulnerability occurs."})]})}function l(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>s});var a=n(67294);const r={},o=a.createContext(r);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);