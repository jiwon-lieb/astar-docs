"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[8529],{3824:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>c,toc:()=>d});var i=n(85893),s=n(11151),a=n(3837);const o={sidebar_position:1,description:"Web3 Functions serve as a comprehensive tool, enabling developers to effortlessly set up, manage, and automate their smart contract tasks"},r="Gelato Web3 Functions",c={id:"build/zkEVM/integrations/automation-off-chain/w3f",title:"Gelato Web3 Functions",description:"Web3 Functions serve as a comprehensive tool, enabling developers to effortlessly set up, manage, and automate their smart contract tasks",source:"@site/docs/build/zkEVM/integrations/automation-off-chain/w3f.md",sourceDirName:"build/zkEVM/integrations/automation-off-chain",slug:"/build/zkEVM/integrations/automation-off-chain/w3f",permalink:"/es/docs/build/zkEVM/integrations/automation-off-chain/w3f",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/zkEVM/integrations/automation-off-chain/w3f.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"Web3 Functions serve as a comprehensive tool, enabling developers to effortlessly set up, manage, and automate their smart contract tasks"},sidebar:"tutorialSidebar",previous:{title:"Automation & Off-chain Data",permalink:"/es/docs/build/zkEVM/integrations/automation-off-chain/"},next:{title:"Asset Bridges",permalink:"/es/docs/build/zkEVM/integrations/bridges-relays/"}},l={},d=[{value:"Overview",id:"overview",level:2},{value:"Triggers",id:"triggers",level:2},{value:"What to Execute?",id:"what-to-execute",level:2},{value:"Typescript Functions",id:"typescript-functions",level:3},{value:"Solidity Functions",id:"solidity-functions",level:3},{value:"Automated Transaction",id:"automated-transaction",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Writing &amp; Deploying Typescript Functions",id:"writing--deploying-typescript-functions",level:3},{value:"Writing &amp; Deploying Solidity Functions",id:"writing--deploying-solidity-functions",level:3},{value:"Demo",id:"demo",level:2}];function h(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"gelato-web3-functions",children:"Gelato Web3 Functions"}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"Gelato's Web3 Functions is a powerful automation system designed to streamline and enhance Web3 operations. Web3 Functions serve as a comprehensive tool, enabling developers to effortlessly set up, manage, and automate their smart contract tasks.\nDetermining your Needs"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Off-chain Data or Computation?"}),"\nSometimes, automation tasks require data that isn't readily available on the blockchain, or they might need computations that are better performed off-chain. In such cases, Typescript Functions should be the choice."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"All Checks On-chain?"}),"\nIf all the conditions necessary for your automation task can be directly verified on the blockchain, you have the option to select between Typescript Functions, Solidity Functions & Automated Transactions"]}),"\n",(0,i.jsx)(t.h2,{id:"triggers",children:"Triggers"}),"\n",(0,i.jsx)(a.Z,{src:n(78872).Z,width:"100%"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Time Interval\nDescription: Use this trigger to execute tasks at regular intervals, e.g., every 10 minutes or once every 24 hours. It's like setting a straightforward, recurring alarm."}),"\n",(0,i.jsx)(t.li,{children:'Cron Expressions\nDescription: This offers a more refined control compared to the Time Interval. With cron expressions, you can set tasks to run at specific moments, such as "every Tuesday at 3 PM" or "on the 1st of every month". It gives you precision in task scheduling.'}),"\n",(0,i.jsx)(t.li,{children:"On-Chain Event\nDescription: Ideal for those wanting their tasks to respond dynamically to blockchain activities. Whenever a specified event occurs on the blockchain, this trigger springs your task into action. It's like a vigilant watcher, always ready to act."}),"\n",(0,i.jsx)(t.li,{children:"Every Block\nDescription: This function operates with the rhythm of the blockchain itself, executing your chosen function each time a new block is created."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"what-to-execute",children:"What to Execute?"}),"\n",(0,i.jsx)(a.Z,{src:n(10053).Z,width:"100%"}),"\n",(0,i.jsx)(t.h3,{id:"typescript-functions",children:"Typescript Functions"}),"\n",(0,i.jsx)(t.p,{children:"Typescript Functions are decentralized cloud functions that work similarly to AWS Lambda or Google Cloud, just for web3. They enable developers to execute on-chain transactions based on arbitrary off-chain data (APIs / subgraphs, etc) & computation. These functions are written in Typescript, stored on IPFS and run by Gelato."}),"\n",(0,i.jsx)(t.h3,{id:"solidity-functions",children:"Solidity Functions"}),"\n",(0,i.jsx)(t.p,{children:'Solidity Functions are crucial for making on-chain tasks automatic and more efficient. They connect set conditions with specific actions in a smart contract, providing a straightforward method to turn user needs into automated processes.\nConsider them as a set of "if-then" rules: If certain conditions are met on the blockchain, then a specific function gets executed. This level of automation ensures that the decentralized application can operate with minimal manual intervention, providing a seamless user experience.'}),"\n",(0,i.jsx)(t.h3,{id:"automated-transaction",children:"Automated Transaction"}),"\n",(0,i.jsx)(t.p,{children:"Automated Transaction ensures that a specific function on the target smart contract gets reliably triggered. When you pre-define the inputs, it means that every time Gelato initiates the function call, it uses consistent, predetermined arguments."}),"\n",(0,i.jsx)(t.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,i.jsx)(t.h3,{id:"writing--deploying-typescript-functions",children:"Writing & Deploying Typescript Functions"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Clone the hardhat-template repo"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:"git clone web3-functions-hardhat-template\n"})}),"\n",(0,i.jsxs)(t.ol,{start:"2",children:["\n",(0,i.jsx)(t.li,{children:"CD into the folder and install"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:"cd web3-functions-hardhat-template && yarn install\n"})}),"\n",(0,i.jsxs)(t.ol,{start:"3",children:["\n",(0,i.jsxs)(t.li,{children:["Update the ",(0,i.jsx)(t.code,{children:"index.ts"})," in one of the examples"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'Web3Function.onRun(async (context: Web3FunctionContext) => {\n  const { userArgs, multiChainProvider } = context;\n\n  const provider = multiChainProvider.default();\n  // Retrieve Last oracle update time\n  const oracleAddress =\n    (userArgs.oracle as string) ?? "0x71B9B0F6C999CBbB0FeF9c92B80D54e4973214da";\n\n  // YOUR CUSTOM LOGIC\n  .....\n\n  // Return if nothing has to be pushed on-chain\n    return { canExec: false, message: `Coingecko call failed` };\n\n  // Return if tx has to be pushed on-chain\n  return {\n    canExec: true,\n    callData: [\n      {\n        to: oracleAddress,\n        data: oracle.interface.encodeFunctionData("updatePrice", [price]),\n      },\n    ],\n  };\n});\n'})}),"\n",(0,i.jsxs)(t.ol,{start:"4",children:["\n",(0,i.jsx)(t.li,{children:"Deploy the Web3 Function to IPFS and create the Task"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:"npx w3f deploy web3-functions/YOUR-FUNCTION/index.ts\n"})}),"\n",(0,i.jsx)(t.p,{children:"Result:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-shell",children:"$ npx w3f deploy web3-functions/YOUR-FUNCTION/index.ts\n \u2713 Web3Function deployed to ipfs.\n \u2713 CID: QmYMysfAhYYYrdhVytSTiE9phuoT49kMByktXSbVp1aRPx\n\nTo create a task that runs your Web3 Function every minute, visit:\n> https://beta.app.gelato.network/new-task?cid=QmYMysfAhYYYrdhVytSTiE9phuoT49kMByktXSbVp1aRPx\n\u2728  Done in 3.56s.\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Finally, go to the ",(0,i.jsx)(t.a,{href:"https://beta.app.gelato.app",children:"Gelato App"}),", create a new task, decide on the trigger, and input the CID."]}),"\n",(0,i.jsx)(t.h3,{id:"writing--deploying-solidity-functions",children:"Writing & Deploying Solidity Functions"}),"\n",(0,i.jsxs)(t.p,{children:["The central part of a solidity function is the ",(0,i.jsx)(t.strong,{children:"Checker"}),". A Checker acts as a bridge between conditions and smart contract executions. Its purpose? To check conditions and determine whether a task should be executed by Gelato. Every checker returns two main things:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"canExec (Boolean): Indicates if Gelato should execute the task."}),"\n",(0,i.jsx)(t.li,{children:"execData (Bytes): Contains the data that executors will use during execution."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Once you have deployed your checker, go to the ",(0,i.jsx)(t.a,{href:"https://beta.app.gelato.app",children:"Gelato App"}),", create a new task, decide the trigger, and input the address of the checker contract and the method that does the check."]}),"\n",(0,i.jsx)(t.h2,{id:"demo",children:"Demo"}),"\n",(0,i.jsxs)(t.p,{children:['We have created a demo showing a "Trailing Stop" strategy leeraging Web3 Functions and ',(0,i.jsx)(t.a,{href:"/es/docs/build/zkEVM/integrations/oracles/pyth",children:"Pyth Oracle"}),". Here the ",(0,i.jsx)(t.a,{href:"https://github.com/gelatodigital/astar-zkatana-w3f-pyth",children:"GitHub repo"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["To do this, we have created a ",(0,i.jsx)(t.code,{children:"MockSwap.sol"})," contract deployed on ",(0,i.jsx)(t.a,{href:"https://zkatana.blockscout.com/address/0x957ce2D8e9E0F584000FbEA2b655e939BE5dfD52",children:"https://zkatana.blockscout.com/address/0x957ce2D8e9E0F584000FbEA2b655e939BE5dfD52"})," that accepts fake USDC deposits, sets the operator to the W3F executor, swaps the USDC into Ether, and creates the W3F with the trailing stop strategy:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"If the price increases, the W3F will push the stop loss."}),"\n",(0,i.jsx)(t.li,{children:"If the price drops, hitting the stop loss, the W3F will swap the eth to usdc again. In this case, the W3F queries the pyth price off-chain and runs the logic. The pyth update price transaction will be sent together with the swap transaction."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The Web3 Function is deployed on ",(0,i.jsx)(t.a,{href:"https://beta.app.gelato.network/functions/task/0x2d376e17ff3b63cf18e623586c51a86843be886457f7809e7194e3aa73f4d00b:1261120",children:"https://beta.app.gelato.network/functions/task/0x2d376e17ff3b63cf18e623586c51a86843be886457f7809e7194e3aa73f4d00b:1261120"})]}),"\n",(0,i.jsx)(a.Z,{caption:"Web3 Function",src:n(65030).Z,width:"100%"})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},3837:(e,t,n)=>{n.d(t,{Z:()=>s});n(67294);var i=n(85893);function s(e){let{src:t,caption:n,width:s="460px"}=e;return(0,i.jsxs)("center",{children:[(0,i.jsx)("br",{}),(0,i.jsxs)("figure",{children:[(0,i.jsx)("img",{src:t,alt:n,width:s}),(0,i.jsx)("figcaption",{children:n})]}),(0,i.jsx)("br",{})]})}},10053:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/functions-0aebeb465850ac053d46ce2912c9ebc6.png"},78872:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/triggers-660d4c7edae2bf8b8c4063cc5556493d.png"},65030:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/w3f-1a5c90bc19993f5ec3d3969fc8c0e3a8.png"},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var i=n(67294);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);