"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[7302],{15346:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>d,toc:()=>c});var t=r(85893),s=r(11151);const a={sidebar_position:1,title:"Technical Solution"},i=void 0,d={id:"build/dapp-staking/technical_solution",title:"Technical Solution",description:"The target audience for this page are developers building projects which interact with dApp Staking protocol.",source:"@site/docs/build/dapp-staking/technical_solution.md",sourceDirName:"build/dapp-staking",slug:"/build/dapp-staking/technical_solution",permalink:"/es/docs/build/dapp-staking/technical_solution",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/dapp-staking/technical_solution.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Technical Solution"},sidebar:"tutorialSidebar",previous:{title:"dApp Staking",permalink:"/es/docs/build/dapp-staking/"},next:{title:"The API and the Indexer",permalink:"/es/docs/build/dapp-staking/indexer/"}},o={},c=[{value:"Pallet Internals",id:"pallet-internals",level:2},{value:"Scenarios",id:"scenarios",level:2},{value:"Staked Amounts In Ledger",id:"staked-amounts-in-ledger",level:3},{value:"Understanding Claimable Eras For Stakers",id:"understanding-claimable-eras-for-stakers",level:3},{value:"Number of Staker Claim Calls Required To Claim All Rewards",id:"number-of-staker-claim-calls-required-to-claim-all-rewards",level:3},{value:"Staker Reward Calculation",id:"staker-reward-calculation",level:3},{value:"dApp Reward Claiming",id:"dapp-reward-claiming",level:3},{value:"Reward Expiry",id:"reward-expiry",level:3},{value:"Bonus Rewards",id:"bonus-rewards",level:3},{value:"Understanding Tier Rewards",id:"understanding-tier-rewards",level:3},{value:"Reward Pools",id:"reward-pools",level:3},{value:"When To Call Expired Entry Cleanup",id:"when-to-call-expired-entry-cleanup",level:3},{value:"Runtime API",id:"runtime-api",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsx)(n.p,{children:"The target audience for this page are developers building projects which interact with dApp Staking protocol."})}),"\n",(0,t.jsxs)(n.p,{children:["Please make sure to check the ",(0,t.jsx)(n.a,{href:"/docs/learn/dapp-staking/dapp-staking-protocol",children:"existing"})," dApp staking protocol documentation before diving into this document."]}),"\n",(0,t.jsx)(n.h2,{id:"pallet-internals",children:"Pallet Internals"}),"\n",(0,t.jsxs)(n.p,{children:["To avoid duplicating information, please check the code documentation for respective crates/modules.\nThe ",(0,t.jsx)(n.em,{children:"rustdoc"})," can be found ",(0,t.jsx)(n.a,{href:"https://astarnetwork.github.io/Astar/astar_collator/index.html",children:"here"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["User is encouraged to check out ",(0,t.jsx)(n.code,{children:"pallet-dapp-staking"}),", ",(0,t.jsx)(n.code,{children:"pallet-evm-precompile-dapp-staking"})," and ",(0,t.jsx)(n.code,{children:"pallet-inflation"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"scenarios",children:"Scenarios"}),"\n",(0,t.jsx)(n.p,{children:"The following subchapters are aimed to help users understand the logic behind some internal workings of the pallet.\nThis information is intended to be complimentary to the aforementioned pallet documentation."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"CurrentProtocolState"})," storage entry is relevant essentially to every functionality, so it won't be repeated in every subchapter."]}),"\n",(0,t.jsx)(n.h3,{id:"staked-amounts-in-ledger",children:"Staked Amounts In Ledger"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"AccountLedger"})," struct contains various pieces of information related to someone's locked & staked amounts.\nFor each staker, an entry of ",(0,t.jsx)(n.code,{children:"AccountLedger"})," is stored in ",(0,t.jsx)(n.code,{children:"Ledger"})," storage map."]}),"\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"staked"})," and ",(0,t.jsx)(n.code,{children:"staked_future"})," fields carry information about how much user has staked at some point.\nIf ",(0,t.jsx)(n.code,{children:"staked_future"})," is not ",(0,t.jsx)(n.code,{children:"None"})," (or ",(0,t.jsx)(n.code,{children:"null"}),"), then it\u2019s guaranteed to have ",(0,t.jsx)(n.code,{children:"era"})," value equal to ",(0,t.jsx)(n.code,{children:"staked.era + 1"}),".\nEach of these entries caries information about certain era or time span."]}),"\n",(0,t.jsx)(n.p,{children:"There are 4 distinct scenarios how these values can appear:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"staked"})," is empty (all zeroes), and ",(0,t.jsx)(n.code,{children:"staked_future"})," is ",(0,t.jsx)(n.code,{children:"None"}),". This means the account has nothing staked."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"staked"})," is non-empty and ",(0,t.jsx)(n.code,{children:"staked_future"})," is ",(0,t.jsx)(n.code,{children:"None"}),'. This can be read as: "Staker has staked ',(0,t.jsx)(n.code,{children:"staked.voting + staked.build_and_earn"})," amount since era ",(0,t.jsx)(n.code,{children:"staked.era"}),'".\nE.g., if ',(0,t.jsx)(n.code,{children:"staked.era = 5"})," and current era is 7, it means that the ",(0,t.jsx)(n.code,{children:"staked"})," entry is valid for eras ",(0,t.jsx)(n.strong,{children:"5, 6 and 7"})," (assuming they all belong to the same period)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"staked"})," is empty (all zeroes), and ",(0,t.jsx)(n.code,{children:"staked_future"})," has some non-zero value. This is interpreted in the same way as the staked value in the previous example."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"staked"})," is non-empty, and ",(0,t.jsx)(n.code,{children:"staked_future"})," has some non-zero value. In this case, ",(0,t.jsx)(n.code,{children:"staked"})," describes ",(0,t.jsx)(n.strong,{children:"a single era"}),", while ",(0,t.jsx)(n.code,{children:"staked_future"})," describes one or more eras.\nE.g. if ",(0,t.jsx)(n.code,{children:"staked.era = 5"})," , and ",(0,t.jsx)(n.code,{children:"staked_future.era = 6"})," it\u2019s interpreted as:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["In era 5, staker has staked ",(0,t.jsx)(n.code,{children:"staked.voting + staked.build_and_earn"})," amount."]}),"\n",(0,t.jsxs)(n.li,{children:["From era 6 and onwards, staker has staked ",(0,t.jsx)(n.code,{children:"staked_future.voting + staked_future.build_and_earn"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"stake"})," and ",(0,t.jsx)(n.code,{children:"staked_future"})," entries are not valid indefinitely, they will expire after the period finishes. However, to expire doesn\u2019t mean they are deleted or anything\nsimilar to that. Instead, ",(0,t.jsx)(n.code,{children:"staked.period"})," or ",(0,t.jsx)(n.code,{children:"staked_future.period"})," need to be checked to understand whether they match the ongoing period number.\nIf they don\u2019t match, they can be ignored & treated as if stake amount is ",(0,t.jsx)(n.strong,{children:"zero"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["E.g. if ",(0,t.jsx)(n.code,{children:"staked.era = 5"})," and ",(0,t.jsx)(n.code,{children:"staked.period = 1"}),", and current period is ",(0,t.jsx)(n.code,{children:"2"}),", we need to check ",(0,t.jsx)(n.code,{children:"PeriodEnd"})," storage map to find out when did ",(0,t.jsx)(n.code,{children:"period 1"})," end.\nLet's assume that ",(0,t.jsx)(n.code,{children:"period 1"})," ended in era 20 - it would mean that the ",(0,t.jsx)(n.code,{children:"staked"})," entry is valid from era 5 up to era 20."]}),"\n",(0,t.jsx)(n.h3,{id:"understanding-claimable-eras-for-stakers",children:"Understanding Claimable Eras For Stakers"}),"\n",(0,t.jsxs)(n.p,{children:["There are two storage entries to consider ",(0,t.jsx)(n.code,{children:"Ledger"})," (",(0,t.jsx)(n.code,{children:"AccountLedger"})," struct) and ",(0,t.jsx)(n.code,{children:"PeriodEnd"})," (",(0,t.jsx)(n.code,{children:"PeriodEndInfo"})," struct)."]}),"\n",(0,t.jsxs)(n.p,{children:["The relevant entries for the ",(0,t.jsx)(n.code,{children:"AccountLedger"})," are ",(0,t.jsx)(n.code,{children:"staked"})," and ",(0,t.jsx)(n.code,{children:"staked_future"}),".\nIn case ",(0,t.jsx)(n.code,{children:"staked_future"})," is not ",(0,t.jsx)(n.code,{children:"None"})," (or not ",(0,t.jsx)(n.code,{children:"null"}),"), then its era ",(0,t.jsx)(n.strong,{children:"must"})," be exactly ",(0,t.jsx)(n.code,{children:"+1"})," compared to the ",(0,t.jsx)(n.code,{children:"staked"})," era.\nE.g. if ",(0,t.jsx)(n.code,{children:"staked.era = 15"})," , then ",(0,t.jsx)(n.code,{children:"staked_future.era"}),", if it exists, must be ",(0,t.jsx)(n.code,{children:"16"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"First step in getting claimable staker reward eras to find the final era for which rewards can be claimed. There are three possibilities:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Rewards have expired and there\u2019s nothing to claim."}),"\n",(0,t.jsxs)(n.li,{children:["Rewards are from a past period (",(0,t.jsx)(n.code,{children:"staker.period"})," or ",(0,t.jsx)(n.code,{children:"staker_future.period"})," is older than the ongoing period) in which case ",(0,t.jsx)(n.code,{children:"PeriodEnd"})," storage entry should be read to find the ending era of that period."]}),"\n",(0,t.jsxs)(n.li,{children:["Rewards are from the ongoing period in which case ending era is ",(0,t.jsx)(n.code,{children:"protocol_state.current_era - 1"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Once we have the ",(0,t.jsx)(n.em,{children:"latest"})," era for which the rewards can be claimed, we can construct a list of claimable eras with their appropriate stake amount."]}),"\n",(0,t.jsxs)(n.p,{children:["There are a few options:\n",(0,t.jsxs)(n.em,{children:["(please note that ",(0,t.jsx)(n.code,{children:".amount"})," notation is just a simplification for ",(0,t.jsx)(n.code,{children:"staked.voting + staked.build_and_earn"})," sum)"]})]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Only ",(0,t.jsx)(n.code,{children:"staked"})," exists, and ",(0,t.jsx)(n.code,{children:"staked_future"})," is ",(0,t.jsx)(n.code,{children:"None"}),". Vector of stake entries looks like ",(0,t.jsx)(n.code,{children:"[(staked.era, staked.amount), (staked.era + 1, staked.amount), ..., (final_era, staked.amount)]"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Only ",(0,t.jsx)(n.code,{children:"staked_future"})," exists, and ",(0,t.jsx)(n.code,{children:"staked"})," only has zero entries. Vector of stake entries looks like ",(0,t.jsx)(n.code,{children:"[(staked_future.era, staked.amount), (staked_future.era + 1, staked_future.amount), ..., (final_era, staked_future.amount)]"})]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"staked"})," and ",(0,t.jsx)(n.code,{children:"staked_future"})," are non-zero. Vector of stake entries looks like ",(0,t.jsx)(n.code,{children:"[(staked.era, staked.amount), (staked_future.era, staked_future.amount), ..., (final_era, staked_future.amount)]"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"number-of-staker-claim-calls-required-to-claim-all-rewards",children:"Number of Staker Claim Calls Required To Claim All Rewards"}),"\n",(0,t.jsxs)(n.p,{children:["Stakers can have many pending rewards if they don't claim regularly. This is normal and expected.\nOne ",(0,t.jsx)(n.code,{children:"claim_staker_rewards"})," call can claim more than 1 such reward."]}),"\n",(0,t.jsxs)(n.p,{children:["To calculate number of calls required to claim ",(0,t.jsx)(n.strong,{children:"all"})," rewards, we need to to the following:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Repeat the step from the subchapter which explains how to get list of claimable eras."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Information about era rewards is stored inside spans - ",(0,t.jsx)(n.code,{children:"EraRewards"})," storage map & ",(0,t.jsx)(n.code,{children:"EraRewardSpan"})," struct.\nSpan length is defined by a runtime constant ",(0,t.jsx)(n.code,{children:"EraRewardSpanLength"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Once we know claimable eras, we need to take the first and last era and put it into the following calculation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:"let first_span_index = (first_era - (first_era % EraRewardSpanLength)) / EraRewardSpanLength;\nlet last_span_index = (last_era - (last_era % EraRewardSpanLength)) / EraRewardSpanLength;\n\nlet number_of_claims = last_span_index - first_span_index + 1;\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["This code assumes that there ",(0,t.jsx)(n.em,{children:"are"})," claimable rewards. if the logic for getting first and/or last era is wrong (e.g. returns a number when there\u2019s nothing to claim), the above formula won\u2019t work."]})}),"\n",(0,t.jsx)(n.h3,{id:"staker-reward-calculation",children:"Staker Reward Calculation"}),"\n",(0,t.jsx)(n.p,{children:"Pending staker reward for a concrete era can be calculated using a simple formula."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Find out the ",(0,t.jsx)(n.code,{children:"total staked amount"})," a staker had in some ",(0,t.jsx)(n.code,{children:"era"}),". See previous chapters on how to extract this information from the ",(0,t.jsx)(n.code,{children:"Ledger"})," storage map."]}),"\n",(0,t.jsxs)(n.li,{children:["Find out how much was staked in total at the end of an ",(0,t.jsx)(n.code,{children:"era"}),", and what the reward pool was. This can be read from the ",(0,t.jsx)(n.code,{children:"EraRewards"})," storage map."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"reward = total_staked_amount  / era_reward.staked * era_reward.staker_reward_pool"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Developer should take note of the order of operations above to prevent overflow/underflow. Due to both ",(0,t.jsx)(n.strong,{children:"ASTR"})," and ",(0,t.jsx)(n.strong,{children:"SDN"})," currency having 18 decimals, ",(0,t.jsx)(n.em,{children:"BigInteger"})," usage is encouraged."]})}),"\n",(0,t.jsx)(n.h3,{id:"dapp-reward-claiming",children:"dApp Reward Claiming"}),"\n",(0,t.jsxs)(n.p,{children:["In order to claim dApp rewards, it is necessary to know ",(0,t.jsx)(n.strong,{children:"exactly"})," which eras have unclaimed reward for the dApp.\nThe relevant storage map is ",(0,t.jsx)(n.code,{children:"DAppTiers"})," which maps ",(0,t.jsx)(n.code,{children:"era"})," to information about dApp tiers & tier rewards."]}),"\n",(0,t.jsxs)(n.p,{children:["After reading ",(0,t.jsx)(n.code,{children:"DappTiers"})," storage map for a particular ",(0,t.jsx)(n.code,{children:"era"}),", ",(0,t.jsx)(n.code,{children:"dapp_tiers_rewards.dapps"})," ",(0,t.jsx)(n.em,{children:"tree map"})," must be checked whether it contains the ",(0,t.jsx)(n.code,{children:"dapp_id"})," of the smart contract for which we want to claim rewards. Please note that ",(0,t.jsx)(n.code,{children:"dapp_id"})," is ",(0,t.jsx)(n.code,{children:"u16"})," dApp identifier which can be read from the ",(0,t.jsx)(n.code,{children:"DAppInfo"})," struct in ",(0,t.jsx)(n.code,{children:"IntegratedDAppsStorage"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["In case entry for the ",(0,t.jsx)(n.code,{children:"dapp_id"})," exists, it will also contain the ",(0,t.jsx)(n.code,{children:"tier_id"})," value which can be used to read the earned dApp reward from ",(0,t.jsx)(n.code,{children:"dapp_tier_info.rewards"}),".\nIt\u2019s enough to use ",(0,t.jsx)(n.code,{children:"tier_id"})," it as index in the ",(0,t.jsx)(n.code,{children:"rewards"})," vector to find the reward associated with that tier."]}),"\n",(0,t.jsxs)(n.p,{children:["Once reward has been claimed, the associated entry will be removed ",(0,t.jsx)(n.code,{children:"dapp_tiers_rewards.dapps"})," ",(0,t.jsx)(n.em,{children:"tree map"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"reward-expiry",children:"Reward Expiry"}),"\n",(0,t.jsx)(n.p,{children:"After predefined amount of periods have passed, unclaimed rewards will expire.\nThis means that staker or dApp owner won't be able to claim these anymore."}),"\n",(0,t.jsx)(n.p,{children:"The oldest period for which the rewards can be claimed can be calculated like this:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"oldest_period = current_period - RewardRetentionInPeriods"})}),"\n",(0,t.jsxs)(n.p,{children:["where ",(0,t.jsx)(n.code,{children:"RewardRetentionInPeriods"})," is a runtime constant."]}),"\n",(0,t.jsxs)(n.p,{children:["This can be used to limit the ",(0,t.jsx)(n.em,{children:"iteration"})," over ",(0,t.jsx)(n.code,{children:"DappTiers"})," storage."]}),"\n",(0,t.jsxs)(n.p,{children:["Once we know the oldest period, we can use ",(0,t.jsx)(n.code,{children:"PeriodEnd"})," storage map to find when did the ",(0,t.jsx)(n.code,{children:"oldest_period - 1"})," period end. The era after that one (or +2 to be more precise since +1 refers to the voting subperiod era) will be the first one that has the potential to be claimable."]}),"\n",(0,t.jsx)(n.h3,{id:"bonus-rewards",children:"Bonus Rewards"}),"\n",(0,t.jsxs)(n.p,{children:["When checking whether staker is eligible for any bonus rewards, it is necessary to check all of the ",(0,t.jsx)(n.code,{children:"StakerInfo"})," double storage map entries related to that staker.\nThe first key of the double map is ",(0,t.jsx)(n.code,{children:"staker account"})," so it can easily be iterated via prefix iteration."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ",(0,t.jsx)(n.code,{children:"staked"})," field of the ",(0,t.jsx)(n.code,{children:"SingularStakingInfo"})," refers to a valid ",(0,t.jsx)(n.strong,{children:"past period"})," (non-expired), and ",(0,t.jsx)(n.code,{children:"loyal_staker"})," flag is set to ",(0,t.jsx)(n.code,{children:"true"}),", it means staker is eligible for the bonus reward."]}),"\n",(0,t.jsxs)(n.p,{children:["It's also required to read the ",(0,t.jsx)(n.code,{children:"PeriodEnd"})," storage map for information about the finished period."]}),"\n",(0,t.jsx)(n.p,{children:"The reward can be calculated as:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"bonus_reward = singular_staking_info.stake_amount.voting / period_end_info.total_vp_stake * period_end_info.bonus_reward_pool"})}),"\n",(0,t.jsx)(n.p,{children:"Once reward has been claimed, the database entry will be cleaned up."}),"\n",(0,t.jsx)(n.h3,{id:"understanding-tier-rewards",children:"Understanding Tier Rewards"}),"\n",(0,t.jsxs)(n.p,{children:["At the end of each ",(0,t.jsx)(n.code,{children:"Build&Earn"})," subperiod era, dApp scores are calculated, and according to them, dApps are assigned into tiers."]}),"\n",(0,t.jsxs)(n.p,{children:["Each tier has a limited capacity, and has a threshold which dApps need to satisfy in order to enter it.\nThe dApp score is simply the total staked amount on the dApp (value can be read from ",(0,t.jsx)(n.code,{children:"ContractStake"})," storage map).\nTiers are described using ",(0,t.jsx)(n.code,{children:"TierConfiguration"})," struct which is stored in ",(0,t.jsx)(n.code,{children:"TierConfig"})," storage.\nUsing that information, dApps are sorted out and assigned into appropriate tiers."]}),"\n",(0,t.jsxs)(n.p,{children:["Once tiers have been assigned, they are stored into ",(0,t.jsx)(n.code,{children:"DAppTiers"})," storage map. This is done at the end of every ",(0,t.jsx)(n.code,{children:"Build&Earn"})," subperiod era, or at the beginning of the block of the next era to be more precise."]}),"\n",(0,t.jsx)(n.p,{children:"Essentially, it is enough to check that storage item once it\u2019s been written to understand how many tier slots have been occupied and how many are unused."}),"\n",(0,t.jsxs)(n.p,{children:["However, it is possible that in that very same block, someone calls ",(0,t.jsx)(n.code,{children:"claim_dapp_reward"})," extrinsic. This will remove some of the entries from the storage, thus not providing the correct picture of tier usage. To build 100% accurate picture of how many slots were occupied:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Find the block at which new era started, when dApps were assigned to tiers."}),"\n",(0,t.jsxs)(n.li,{children:["Use Runtime Call API to get the tier assignment for the ",(0,t.jsx)(n.strong,{children:"previous block"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"reward-pools",children:"Reward Pools"}),"\n",(0,t.jsxs)(n.p,{children:["Reward pools per era can be read from the ",(0,t.jsx)(n.code,{children:"Inflation"})," pallet, by reading the ",(0,t.jsx)(n.code,{children:"ActiveInflationConfig"})," storage value."]}),"\n",(0,t.jsxs)(n.p,{children:["Each tier gets a portion of the reward pool (denoted as ",(0,t.jsx)(n.code,{children:"reward_portion"})," in the configuration). These portions are further partitioned per slots."]}),"\n",(0,t.jsx)(n.p,{children:"E.g. for tier 1 dApp reward is calculated as:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"tier_1_dapp_reward = dapp_reward_pool_per_era * reward_portion[0] / slots_per_tier[0]"})}),"\n",(0,t.jsx)(n.h3,{id:"when-to-call-expired-entry-cleanup",children:"When To Call Expired Entry Cleanup"}),"\n",(0,t.jsxs)(n.p,{children:["Each account can have a limited amount of ",(0,t.jsx)(n.code,{children:"ContractStakeEntries"}),". This is denoted by ",(0,t.jsx)(n.code,{children:"MaxNumberOfStakedContracts"})," runtime constant."]}),"\n",(0,t.jsxs)(n.p,{children:["If an account has number of contract stake entries equal to the limit, calling ",(0,t.jsx)(n.code,{children:"stake"})," might fail due to an ",(0,t.jsx)(n.code,{children:"TooManyStakedContracts"})," error.\nA special extrinsic call, ",(0,t.jsx)(n.code,{children:"cleanup_expired_entries"})," can be used to do the cleanup of expired entries to help with this problem."]}),"\n",(0,t.jsx)(n.p,{children:"Entry is considered to be expired if:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"It's from a past period & the account wasn't a loyal staker, meaning there's no claimable bonus reward."}),"\n",(0,t.jsx)(n.li,{children:"It's from a period older than the oldest claimable period, regardless whether the account was loyal or not."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"However, it is possible that the aforementioned cleanup call won\u2019t work if the staker account is trying to stake on more contracts than it is allowed.\nIn that case, staker should simply claim their pending rewards before attempting future actions."}),"\n",(0,t.jsx)(n.h3,{id:"runtime-api",children:"Runtime API"}),"\n",(0,t.jsxs)(n.p,{children:["Runtimes supporting ",(0,t.jsx)(n.code,{children:"dapp-staking-v3"})," functionality will also expose runtime API called: ",(0,t.jsx)(n.code,{children:"DappStakingApi"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Please refer ",(0,t.jsx)(n.a,{href:"https://github.com/AstarNetwork/Astar/tree/master/pallets/dapp-staking-v3/rpc/runtime-api",children:"here"})," for a list of supported functions."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>d,a:()=>i});var t=r(67294);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);