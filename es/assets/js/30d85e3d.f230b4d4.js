"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[6873],{29227:(a,e,n)=>{n.r(e),n.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=n(85893),t=n(11151);const i={sidebar_position:9},r="Aplicaciones de cliente",o={id:"learn/interoperability/xcm/building-with-xcm/client-applications",title:"Aplicaciones de cliente",description:"En este cap\xedtulo, examinaremos c\xf3mo utilizar TypeScript para interactuar con la paleta XCM y construir transacciones XCM. Con esta informaci\xf3n, podr\xe1s crear una dApp o puente XCM.",source:"@site/i18n/es/docusaurus-plugin-content-docs/current/learn/interoperability/xcm/building-with-xcm/client-applications.md",sourceDirName:"learn/interoperability/xcm/building-with-xcm",slug:"/learn/interoperability/xcm/building-with-xcm/client-applications",permalink:"/es/docs/learn/interoperability/xcm/building-with-xcm/client-applications",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/learn/interoperability/xcm/building-with-xcm/client-applications.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Retirar activos",permalink:"/es/docs/learn/interoperability/xcm/building-with-xcm/xc-assets-withdraw"},next:{title:"FAQ sobre contratos inteligentes",permalink:"/es/docs/learn/interoperability/xcm/building-with-xcm/faq-for-smart-contracts"}},c={},d=[];function l(a){const e={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",...(0,t.a)(),...a.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"aplicaciones-de-cliente",children:"Aplicaciones de cliente"}),"\n",(0,s.jsx)(e.p,{children:"En este cap\xedtulo, examinaremos c\xf3mo utilizar TypeScript para interactuar con la paleta XCM y construir transacciones XCM. Con esta informaci\xf3n, podr\xe1s crear una dApp o puente XCM."}),"\n",(0,s.jsxs)(e.p,{children:["Al interactuar con la paleta XCM a trav\xe9s del RPC de Substrate, haremos uso del paquete ",(0,s.jsx)(e.a,{href:"https://github.com/polkadot-js/api",children:(0,s.jsx)(e.code,{children:"polkadot api"})})," a lo largo de este cap\xedtulo."]}),"\n",(0,s.jsx)(e.p,{children:"En primer lugar, tendr\xe1s que inicializar la API como har\xedas con cualquier otra aplicaci\xf3n Substrate."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import { ApiPromise, WsProvider } from '@polkadot/api';\n\nconst myApp = async () => {\n    const provider = new WsProvider('wss://rpc.shiden.astar.network');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n  const paraId = await chainApi.query.parachainInfo.parachainId.toString();\n \n  // Deber\xeda salir 2007\n  console.log(paraId)\n};\n"})}),"\n",(0,s.jsxs)(e.p,{children:["En Astar Network, utilizamos la ",(0,s.jsx)(e.a,{href:"https://github.com/paritytech/substrate/tree/master/frame/assets",children:"paleta Assets de Substrate"})," para manejar la representaci\xf3n XCM de multi-asset. Recuperemos la lista de activos de la red."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:" \n// importamos los tipos conocidos\nimport { AssetMetadata, AssetDetails } from '@polkadot/types/interfaces';\n\n// creamos una interfaz personalizada para mayor comodidad\ninterface ChainAsset extends AssetDetails {\n    id: string;\n    metadata: AssetMetadata;\n}\n\n  //...corte r\xe1pido\n\n  // nota: Tenga en cuenta que esta funci\xf3n requiere que la cadena implemente la paleta Assets\n\n    // nota: El ID del activo tendr\xe1 diferentes significados dependiendo del rango\n    // 1 ~ 2^32-1 = Activos definidos por el usuario. Cualquiera puede registrar estos activos en la cadena.\n    // 2^32 ~ 2^64-1 = Mapa de activos de Statemine/Statemint. Este es un mapa directo de todos los activos almacenados en la cadena de estado de bienes comunes.\n    // 2^64 ~ 2^128-1 = Activos del ecosistema como activos nativos en otro parachain u otros tokens valiosos.\n    // 2^128 ~ 1 = Ficha nativa en el Relaychain (DOT o KSM).\n\n    const assetsListRaw = await chainApi.query.assets.asset.entries();\n    const assetMetadataListRaw = await chainApi.query.assets.metadata.entries();\n\n    const assetInfos = assetsListRaw.map((i, index) => {\n        const assetId = (i[0].toHuman() as string[])[0].replaceAll(',', '');\n        const assetInfo = i[1].toHuman() as any as AssetDetails;\n        const metadata = assetMetadataListRaw[index][1].toHuman() as any as AssetMetadata;\n        return {\n            id: assetId,\n            ...assetInfo,\n            metadata,\n        } as ChainAsset;\n    });\n    // convierte la lista en una cadena de n\xfameros sin la coma y sin entradas anidadas\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"Al ejecutar esta funci\xf3n se obtendr\xe1 una lista de los activos registrados en la cadena. Esto resulta \xfatil cuando se desea crear una interfaz de usuario (IU) que enumere todos los activos posibles, incluidos los compatibles con XCM."}),"\n",(0,s.jsxs)(e.p,{children:["A continuaci\xf3n, vamos a ejecutar una funci\xf3n de consenso cruzado. Las parachains tendr\xe1n una paleta llamada ",(0,s.jsx)(e.code,{children:"polkadotXcm"}),", mientras que las Relay Chains usar\xe1n la paleta ",(0,s.jsx)(e.code,{children:"xcmPallet"}),". Ambos utilizar\xe1n las mismas funciones y sintaxis para enviar transacciones XCM."]}),"\n",(0,s.jsx)(e.p,{children:"En este ejemplo, enviaremos el activo de la Relay Chain a la parachain, como hemos hecho en cap\xedtulos anteriores, pero esta vez, usaremos TypeScript."}),"\n",(0,s.jsx)(e.p,{children:"Vamos a crear dos instancias de la API, una para la parachain y otra para la Relay Chain. Aunque para nuestro ejemplo, s\xf3lo llamaremos a la extr\xednseca desde la Relay Chain, e inicializaremos la instancia de la API de la parachain para obtener din\xe1micamente el ID de dicha parachain."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Vec, u32 } from '@polkadot/types';\n\nconst parachainApi = async () => {\n    const provider = new WsProvider('wss://rpc.shiden.astar.network');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n    const paraId = (await chainApi.query.parachainInfo.parachainId()).toString();\n\n    // Deber\xeda imprimir 2007\n    console.log(paraId);\n    return chainApi;\n};\n\nconst relaychainApi = async () => {\n    const provider = new WsProvider('wss://kusama-rpc.polkadot.io');\n    const chainApi = await (new ApiPromise({ provider })).isReady;\n\n    const parachains = ((await chainApi.query.paras.parachains()) as Vec<u32>).map((i) => i.toNumber());\n\n    // Deber\xeda mostrar una lista con los IDs de la parachain \n    console.log(parachains);\n    return chainApi;\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"A continuaci\xf3n, creamos la funci\xf3n principal para gestionar la transacci\xf3n XCM real."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"import { Keyring } from '@polkadot/keyring';\nimport { decodeAddress, cryptoWaitReady } from '@polkadot/util-crypto';\n\nconst myApp = async () => {\n  await cryptoWaitReady();\n\n    const keyring = new Keyring({ type: 'sr25519' });\n    // aseg\xfarese de que esta cuenta tiene algo de token KSM\n    const account = keyring.addFromUri('account seed', { name: 'Default' }, 'sr25519');\n\n    const parachainApiInst = await parachainApi();\n    const relaychainApiInst = await relaychainApi();\n\n    const parachainId = await parachainApiInst.query.parachainInfo.parachainId.toString();\n    \n    // la parachain objetivo conectada a la relaychain actual\n    const dest = {\n        V1: {\n            interior: {\n                X1: {\n                    Parachain: parachainId,\n                },\n            },\n            parents: 0,\n        },\n    };\n    // la identificaci\xf3n de la cuenta dentro de la parachain de destino\n    const beneficiary = {\n        V1: {\n            interior: {\n                X1: {\n                    AccountId32: {\n                        network: 'Any',\n                        id: decodeAddress(account.address),\n                    },\n                },\n            },\n            parents: 0,\n        },\n    };\n\n  // 1 KSM\n    const amountToSend = new BN(10).pow(new BN(12));\n    // cantidad de tokens fungibles a transferir\n    const assets = {\n        V1: [\n            {\n                fun: {\n                    Fungible: amountToSend,\n                },\n                id: {\n                    Concrete: {\n                        interior: 'Here',\n                        parents: 0,\n                    },\n                },\n            },\n        ],\n    };\n\n    const txHash = await relaychainApiInst.tx.xcmPallet.reserveTransferAssets(dest, beneficiary, assets, 0).signAndSend(account);\n};\n"})}),"\n",(0,s.jsx)(e.p,{children:"En resumen, la primera mitad de la funci\xf3n carga la cuenta que enviar\xe1 los KSM e inicializa la API. La verdadera magia ocurre en la segunda mitad de la funci\xf3n."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"    // la parachain objetivo conectada a la relaychain actual\n    const dest = {\n        V1: {\n            interior: {\n                X1: {\n                    Parachain: parachainId,\n                },\n            },\n            parents: 0,\n        },\n    };\n    // el ID de la cuenta dentro de la parachin de destino\n    const beneficiary = {\n        V1: {\n            interior: {\n                X1: {\n                    AccountId32: {\n                        network: 'Any',\n                        id: decodeAddress(account.address),\n                    },\n                },\n            },\n            parents: 0,\n        },\n    };\n\n  // 1 KSM\n    const amountToSend = new BN(10).pow(new BN(12));\n    // cantidad de tokens fungibles a tranferir\n    const assets = {\n        V1: [\n            {\n                fun: {\n                    Fungible: amountToSend,\n                },\n                id: {\n                    Concrete: {\n                        interior: 'Here',\n                        parents: 0,\n                    },\n                },\n            },\n        ],\n    };\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Como puedes ver, el 'dest' se refiere al destino o cadena objetivo que recibir\xe1 el activo identificado por el ID de la parachain. El ",(0,s.jsx)(e.code,{children:"beneficiary"})," se refiere a la cuenta dentro de la parachain que recibir\xe1 el token. Finalmente, el par\xe1metro 'assets' se refiere a la cantidad que deseas enviar. Por \xfaltimo, podemos firmar la transacci\xf3n con la siguiente funci\xf3n:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// Esto puede ser cero\nconst feeAsset = 0;\nconst txHash = await relaychainApiInst.tx.xcmPallet.reserveTransferAssets(dest, beneficiary, assets, feeAsset).signAndSend(account);\n"})}),"\n",(0,s.jsx)(e.p,{children:"Ahora, una vez que finalices la transacci\xf3n XCM, puedes listar todos los activos con el siguiente script:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"const assetsListRaw = await parachainApiInst.query.assets.asset.entries();\nconst assetMetadataListRaw = await parachainApiInst.query.assets.metadata.entries();\n\nconst assetInfos = assetsListRaw.map((i, index) => {\n    const assetId = (i[0].toHuman() as string[])[0].replaceAll(',', '');\n    const assetInfo = i[1].toHuman() as any as AssetDetails;\n    const metadata = assetMetadataListRaw[index][1].toHuman() as any as AssetMetadata;\n    return {\n        id: assetId,\n        ...assetInfo,\n        metadata,\n    } as ChainAsset;\n});\n\nconst assetBalance = await Promise.all(assetInfos.map(async (i) => {\n    const balance = await parachainApiInst.query.assets.account(i.id, account.address);\n    return {\n        symbol: i.metadata.symbol.toString(),\n        balance: balance.toString(),\n    }\n}))\n\nconsole.log(assetBalance);\n"})}),"\n",(0,s.jsx)(e.p,{children:"Ahora, deber\xedas poder transferir el activo desde la Relay Chain a la parachain y verificar si fue exitoso listando todos los activos dentro del paquete de activos que posee la cuenta actual."}),"\n",(0,s.jsxs)(e.p,{children:["Ten en cuenta que la tarifa de gas se deducir\xe1 del monto transferido, por lo que debe ajustarse en consecuencia, bas\xe1ndose en la tarifa de gas estimada. Por favor consulta la ",(0,s.jsx)(e.a,{href:"https://app.gitbook.com/o/-LgGrgOEDyFYjYWIb1DT/s/-M8GVK5H7hOsGnYqg-7q-872737601/~/changes/aJQFFWQNMjlao1SSjj4a/build/api/gas-price-api",children:"API del precio del gas"})," si es necesario, para casos de uso espec\xedficos."]}),"\n",(0,s.jsxs)(e.p,{children:["Puedes encontrar un proyecto completo que integra funcionalidades similares en ",(0,s.jsx)(e.a,{href:"https://github.com/AstarNetwork/astar-xcm-tools",children:"este repositorio"}),"."]})]})}function p(a={}){const{wrapper:e}={...(0,t.a)(),...a.components};return e?(0,s.jsx)(e,{...a,children:(0,s.jsx)(l,{...a})}):l(a)}},11151:(a,e,n)=>{n.d(e,{Z:()=>o,a:()=>r});var s=n(67294);const t={},i=s.createContext(t);function r(a){const e=s.useContext(i);return s.useMemo((function(){return"function"==typeof a?a(e):{...e,...a}}),[e,a])}function o(a){let e;return e=a.disableParentContext?"function"==typeof a.components?a.components(t):a.components||t:r(a.components),s.createElement(i.Provider,{value:e},a.children)}}}]);