"use strict";(self.webpackChunkdocs_1=self.webpackChunkdocs_1||[]).push([[2625],{31551:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var r=t(85893),a=t(11151);const i={sidebar_position:2},s="Create Pair",c={id:"build/wasm/from-zero-to-ink-hero/dex/Factory/create-pair",title:"Create Pair",description:"If you are starting the tutorial from here, please check out this branch and open it in your IDE.",source:"@site/docs/build/wasm/from-zero-to-ink-hero/dex/Factory/create-pair.md",sourceDirName:"build/wasm/from-zero-to-ink-hero/dex/Factory",slug:"/build/wasm/from-zero-to-ink-hero/dex/Factory/create-pair",permalink:"/es/docs/build/wasm/from-zero-to-ink-hero/dex/Factory/create-pair",draft:!1,unlisted:!1,editUrl:"https://github.com/AstarNetwork/astar-docs/tree/main/docs/build/wasm/from-zero-to-ink-hero/dex/Factory/create-pair.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Factory Storage and Getters",permalink:"/es/docs/build/wasm/from-zero-to-ink-hero/dex/Factory/getters"},next:{title:"Custom Modifier",permalink:"/es/docs/build/wasm/from-zero-to-ink-hero/dex/Factory/modifiers"}},o={},d=[{value:"1. Add Create Pair to Factory Trait",id:"1-add-create-pair-to-factory-trait",level:2},{value:"2. Implement Create Pair",id:"2-implement-create-pair",level:2},{value:"1. Checks that addresses are not identical",id:"1-checks-that-addresses-are-not-identical",level:4},{value:"2. Order The Tuple",id:"2-order-the-tuple",level:3},{value:"3. Check if the First Tuple Address is not the ZERO_ADDRESS",id:"3-check-if-the-first-tuple-address-is-not-the-zero_address",level:4},{value:"4. Instantiate the Pair Contract",id:"4-instantiate-the-pair-contract",level:3},{value:"5. Initialize Pair",id:"5-initialize-pair",level:2},{value:"6. Create Storage Mappings in Both Directions and Push the Pair Address to <code>all_pairs</code>",id:"6-create-storage-mappings-in-both-directions-and-push-the-pair-address-to-all_pairs",level:4},{value:"6. Emit a <code>create_pair</code> Event",id:"6-emit-a-create_pair-event",level:4},{value:"7. Return the Address of the Instantiated Contract",id:"7-return-the-address-of-the-instantiated-contract",level:4},{value:"3. Implement Event",id:"3-implement-event",level:3},{value:"4. Override <code>_instantiate_pair</code>",id:"4-override-_instantiate_pair",level:3},{value:"1. Get pair code_hash from storage",id:"1-get-pair-code_hash-from-storage",level:4},{value:"2. Instantiate Pair",id:"2-instantiate-pair",level:4},{value:"3. Return Pair Address",id:"3-return-pair-address",level:4},{value:"5. Implement Error Handling",id:"5-implement-error-handling",level:3}];function l(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"create-pair",children:"Create Pair"}),"\n",(0,r.jsxs)(n.p,{children:["If you are starting the tutorial from here, please check out this ",(0,r.jsx)(n.a,{href:"https://github.com/AstarNetwork/wasm-tutorial-dex/tree/tutorial/storage-end",children:"branch"})," and open it in your IDE."]}),"\n",(0,r.jsx)(n.h2,{id:"1-add-create-pair-to-factory-trait",children:"1. Add Create Pair to Factory Trait"}),"\n",(0,r.jsxs)(n.p,{children:["We will implement the ",(0,r.jsx)(n.a,{href:"https://github.com/Uniswap/v2-core/blob/ee547b17853e71ed4e0101ccfd52e70d5acded58/contracts/UniswapV2Factory.sol#L23",children:"createPair"})," function of the Factory contract.",(0,r.jsx)(n.br,{}),"\n","In the ",(0,r.jsx)(n.em,{children:"./logics/traits/factory.rs"})," file, add the ",(0,r.jsx)(n.strong,{children:"create_pair"})," function to the Factory trait, as well as the internal child function ",(0,r.jsx)(n.strong,{children:"_instantiate_pair"})," that will need to be implemented in the contract crate.\nThe reason why we need an internal ",(0,r.jsx)(n.strong,{children:"_instantiate_pair"})," function here is because the instantiate builder is not part of the ",(0,r.jsx)(n.code,{children:"#[openbrush::wrapper]"}),", so we will need to use the one from ink! by importing the Pair contract as an ",(0,r.jsx)(n.code,{children:"ink-as-dependancy"}),".\nThe ",(0,r.jsx)(n.strong,{children:"create_pair"})," message function returns the address of the instantiated Pair contract.\nThe function that emits a create_pair event will also have to be implemented in the contract:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"pub trait Factory {\n    ...\n    #[ink(message)]\n    fn create_pair(\n        &mut self,\n        token_a: AccountId,\n        token_b: AccountId,\n    ) -> Result<AccountId, FactoryError>;\n\n    fn _instantiate_pair(&mut self, salt_bytes: &[u8]) -> Result<AccountId, FactoryError>;\n    ...\n    fn _emit_create_pair_event(\n        &self,\n        _token_0: AccountId,\n        _token_1: AccountId,\n        _pair: AccountId,\n        _pair_len: u64,\n    );\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"2-implement-create-pair",children:"2. Implement Create Pair"}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"./logics/impls/factory/factory.rs"})," file, let's implement the ",(0,r.jsx)(n.strong,{children:"create_pair"})," function body:"]}),"\n",(0,r.jsx)(n.h4,{id:"1-checks-that-addresses-are-not-identical",children:"1. Checks that addresses are not identical"}),"\n",(0,r.jsxs)(n.p,{children:["AccountId derives ",(0,r.jsx)(n.code,{children:"Eq"})," trait, so comparison operators can be used:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"impl<T: Storage<data::Data>> Factory for T {\n    ...\n    fn create_pair(\n        &mut self,\n        token_a: AccountId,\n        token_b: AccountId,\n    ) -> Result<AccountId, FactoryError> {\n        if token_a == token_b {\n            return Err(FactoryError::IdenticalAddresses)\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-order-the-tuple",children:"2. Order The Tuple"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let token_pair = if token_a < token_b {\n    (token_a, token_b)\n} else {\n    (token_b, token_a)\n};\n"})}),"\n",(0,r.jsx)(n.h4,{id:"3-check-if-the-first-tuple-address-is-not-the-zero_address",children:"3. Check if the First Tuple Address is not the ZERO_ADDRESS"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"if token_pair.0 == ZERO_ADDRESS.into() {\n    return Err(FactoryError::ZeroAddress)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-instantiate-the-pair-contract",children:"4. Instantiate the Pair Contract"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"https://github.com/paritytech/substrate/blob/982f5998c59bd2bd455808345ae1bd2b1767f353/frame/contracts/src/lib.rs#L187",children:"generate_address"})," function in ",(0,r.jsx)(n.code,{children:"pallet_contracts"})," is akin to the formula of ETH's CREATE2 opcode. There is no CREATE equivalent because CREATE2 is strictly more powerful. Formula: ",(0,r.jsx)(n.code,{children:"hash(deploying_address ++ code_hash ++ salt)"}),"\nInstantiation of a contract will define its own contract address by using the concatenated hash of:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"salt (in bytes)"}),"\n",(0,r.jsx)(n.li,{children:"address of deployer"}),"\n",(0,r.jsx)(n.li,{children:"code_hash"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["As the ",(0,r.jsx)(n.code,{children:"code_hash"})," and ",(0,r.jsx)(n.code,{children:"deployer"})," (Factory contract address) values will be unchanged during each call, the ",(0,r.jsx)(n.code,{children:"salt_bytes"})," value must be unique for each call. As the Factory contract will instantiate a unique Pair contract for each pair, we will hash over the token address to produce a unique salt:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"let salt = Self::env().hash_encoded::<Blake2x256, _>(&token_pair);\nlet pair_contract = self._instantiate_pair(salt.as_ref())?;\n"})}),"\n",(0,r.jsx)(n.h2,{id:"5-initialize-pair",children:"5. Initialize Pair"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"PairRef::initialize(&pair_contract, token_pair.0, token_pair.1)?;\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"6-create-storage-mappings-in-both-directions-and-push-the-pair-address-to-all_pairs",children:["6. Create Storage Mappings in Both Directions and Push the Pair Address to ",(0,r.jsx)(n.code,{children:"all_pairs"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"self.data::<data::Data>()\n    .get_pair\n    .insert(&(token_pair.0, token_pair.1), &pair_contract);\nself.data::<data::Data>()\n    .get_pair\n    .insert(&(token_pair.1, token_pair.0), &pair_contract);\nself.data::<data::Data>().all_pairs.push(pair_contract);\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"6-emit-a-create_pair-event",children:["6. Emit a ",(0,r.jsx)(n.code,{children:"create_pair"})," Event"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"self._emit_create_pair_event(\n    token_pair.0,\n    token_pair.1,\n    pair_contract,\n    self.all_pair_length(),\n);\n"})}),"\n",(0,r.jsx)(n.h4,{id:"7-return-the-address-of-the-instantiated-contract",children:"7. Return the Address of the Instantiated Contract"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"Ok(pair_contract)\n"})}),"\n",(0,r.jsx)(n.p,{children:"The entire function should look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"    fn create_pair(\n    &mut self,\n    token_a: AccountId,\n    token_b: AccountId,\n) -> Result<AccountId, FactoryError> {\n    if token_a == token_b {\n        return Err(FactoryError::IdenticalAddresses)\n    }\n    let token_pair = if token_a < token_b {\n        (token_a, token_b)\n    } else {\n        (token_b, token_a)\n    };\n    if token_pair.0 == ZERO_ADDRESS.into() {\n        return Err(FactoryError::ZeroAddress)\n    }\n\n    let salt = Self::env().hash_encoded::<Blake2x256, _>(&token_pair);\n    let pair_contract = self._instantiate_pair(salt.as_ref())?;\n\n    PairRef::initialize(&pair_contract, token_pair.0, token_pair.1)?;\n\n    self.data::<data::Data>()\n        .get_pair\n        .insert(&(token_pair.0, token_pair.1), &pair_contract);\n    self.data::<data::Data>()\n        .get_pair\n        .insert(&(token_pair.1, token_pair.0), &pair_contract);\n    self.data::<data::Data>().all_pairs.push(pair_contract);\n\n    self._emit_create_pair_event(\n        token_pair.0,\n        token_pair.1,\n        pair_contract,\n        self.all_pair_length(),\n    );\n\n    Ok(pair_contract)\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Implement an ",(0,r.jsx)(n.strong,{children:"_instantiate_pair"})," function with an ",(0,r.jsx)(n.code,{children:"unimplemented!()"})," macro in the body, to ensure it will be overridden (",(0,r.jsx)(n.code,{children:"default"})," keyword should be added):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"default fn _instantiate_pair(&mut self, _salt_bytes: &[u8]) -> Result<AccountId, FactoryError> {\n    // needs to be overridden in contract\n    unimplemented!()\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Add import statements:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"use crate::traits::pair::PairRef;\npub use crate::{\n    impls::factory::*,\n    traits::factory::*,\n};\nuse ink::env::hash::Blake2x256;\nuse openbrush::traits::{\n    AccountId,\n    Storage,\n    ZERO_ADDRESS,\n};\n...\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-implement-event",children:"3. Implement Event"}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"./logics/impls/factory/factory.rs"})," file, add empty implementation of ",(0,r.jsx)(n.strong,{children:"_emit_create_pair_event"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"default fn _emit_create_pair_event(\n    &self,\n    _token_0: AccountId,\n    _token_1: AccountId,\n    _pair: AccountId,\n    _pair_len: u64,\n) {\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Within the contracts folder, in the ",(0,r.jsx)(n.em,{children:"./contracts/factory/lib.rs"})," file, add a ",(0,r.jsx)(n.code,{children:"PairCreated"})," event struct and override the implementation of emit event:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"...\nuse ink::{\n    codegen::{\n        EmitEvent,\n        Env,\n    },\n    ToAccountId,\n};\n...\n#[ink(event)]\npub struct PairCreated {\n    #[ink(topic)]\n    pub token_0: AccountId,\n    #[ink(topic)]\n    pub token_1: AccountId,\n    pub pair: AccountId,\n    pub pair_len: u64,\n}\n...\nimpl Factory for FactoryContract {\n    fn _emit_create_pair_event(\n        &self,\n        token_0: AccountId,\n        token_1: AccountId,\n        pair: AccountId,\n        pair_len: u64,\n    ) {\n        EmitEvent::<FactoryContract>::emit_event(\n            self.env(),\n            PairCreated {\n                token_0,\n                token_1,\n                pair,\n                pair_len,\n            },\n        )\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"4-override-_instantiate_pair",children:["4. Override ",(0,r.jsx)(n.code,{children:"_instantiate_pair"})]}),"\n",(0,r.jsxs)(n.p,{children:["As it's not possible to call a constructor of a contract using ",(0,r.jsx)(n.code,{children:"#[openbrush::wrapper]"}),", we will need to use a contract Ref from ink!.",(0,r.jsx)(n.br,{}),"\n","If you would like to import a contract as an ",(0,r.jsx)(n.code,{children:"ink-as-dependency"}),", it should be built as a library crate ",(0,r.jsx)(n.code,{children:"rlib"}),". Add this to the ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," of the Pair contract in the ",(0,r.jsx)(n.em,{children:"./contracts/pair/Cargo.toml"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'...\n[lib]\nname = "pair_contract"\npath = "lib.rs"\ncrate-type = [\n    "cdylib",\n    "rlib"\n]\n...\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Then import the Pair contract as an ",(0,r.jsx)(n.code,{children:"ink-as-dependency"})," in the Factory contract. Add the dependency to the ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," of the Factory contract in the ",(0,r.jsx)(n.em,{children:"./contracts/factory/Cargo.toml"})," file:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'...\npair_contract = { path = "../pair", default-features = false, features = ["ink-as-dependency"] }\n...\n[features]\ndefault = ["std"]\nstd = [\n"ink/std",\n"scale/std",\n"scale-info/std",\n"openbrush/std",\n"uniswap_v2/std",\n"pair_contract/std",\n]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In the contract crate ",(0,r.jsx)(n.em,{children:"./contracts/factory/lib.rs"})," add import statements:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"...\nuse openbrush::traits::{\n    Storage,\n    ZERO_ADDRESS,\n};\nuse pair_contract::pair::PairContractRef;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.strong,{children:"_instantiate_pair"})," function body:"]}),"\n",(0,r.jsx)(n.h4,{id:"1-get-pair-code_hash-from-storage",children:"1. Get pair code_hash from storage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"...\nimpl Factory for FactoryContract {\n    fn _instantiate_pair(&mut self, salt_bytes: &[u8]) -> Result<AccountId, FactoryError> {\n        let pair_hash = self.factory.pair_contract_code_hash;\n    }\n    ...\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"2-instantiate-pair",children:"2. Instantiate Pair"}),"\n",(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.a,{href:"https://github.com/paritytech/ink/blob/ad4f5e579e39926704e182736af4fa945982ac2b/crates/env/src/call/create_builder.rs#L269",children:"create builder"})," from ink! we call a ",(0,r.jsx)(n.strong,{children:"new"})," constructor from Pair, and pass no endowment (as storage rent has been removed it is not needed). This returns the accountId back to the caller:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"...\nlet pair = match PairContractRef::new()\n    .endowment(0)\n    .code_hash(pair_hash)\n    .salt_bytes(&salt_bytes[..4])\n    .try_instantiate()\n{\n    Ok(Ok(res)) => Ok(res),\n    _ => Err(FactoryError::PairInstantiationFailed),\n}?;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"3-return-pair-address",children:"3. Return Pair Address"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"...\nOk(pair.to_account_id())\n"})}),"\n",(0,r.jsx)(n.p,{children:"Full function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:"fn _instantiate_pair(&mut self, salt_bytes: &[u8]) -> Result<AccountId, FactoryError> {\n    let pair_hash = self.factory.pair_contract_code_hash;\n    let pair = match PairContractRef::new()\n        .endowment(0)\n        .code_hash(pair_hash)\n        .salt_bytes(&salt_bytes[..4])\n        .try_instantiate()\n    {\n        Ok(Ok(res)) => Ok(res),\n        _ => Err(FactoryError::PairInstantiationFailed),\n    }?;\n    Ok(pair.to_account_id())\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-implement-error-handling",children:"5. Implement Error Handling"}),"\n",(0,r.jsxs)(n.p,{children:["In the ",(0,r.jsx)(n.em,{children:"./logics/traits/factory.rs"})," file, implement ",(0,r.jsx)(n.code,{children:"From"})," trait from ",(0,r.jsx)(n.code,{children:"PairError"})," and add it to ",(0,r.jsx)(n.code,{children:"FactoryError"}),". Also add Error variants used in the create pair implementation:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use crate::traits::pair::PairError;\n...\n#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]\npub enum FactoryError {\n    PairError(PairError),\n    ZeroAddress,\n    IdenticalAddresses,\n    PairInstantiationFailed,\n}\n\nimpl From<PairError> for FactoryError {\n    fn from(error: PairError) -> Self {\n        FactoryError::PairError(error)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"And that's it! Check your Factory contract with (run in contract folder):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-console",children:"cargo contract build\n"})}),"\n",(0,r.jsxs)(n.p,{children:["It should now look like this ",(0,r.jsx)(n.a,{href:"https://github.com/AstarNetwork/wasm-tutorial-dex/tree/tutorial/factory_create_pair_end",children:"branch"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},11151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>s});var r=t(67294);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);